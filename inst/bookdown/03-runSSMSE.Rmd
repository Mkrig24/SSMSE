# Options for run_SSMSE {#SSMSE}

Many inputs are possible for the `run_SSMSE()` option. Here, we will describe some of the options available. For detailed documentation, type `?SSMSE::run_SSMSE()` into the R console.

## Scenarios in SSMSE

Note that multiple scenarios can be called in `run_SSMSE()`, often through vector inputs to `run_SSMSE()`. Below, we will describe inputs needed to run 1 scenario.

## Operating model

The operating model (OM) for SSMSE should be a Stock Synthesis model. This could be any fitted Stock Synthesis model. There is one built-in OM that comes with SSMSE, which is a cod-like model. To use the cod model in run_SSMSE, set `OM_name_vec = "cod"`. Otherwise, the path to the OM model should be specified in `OM_in_dir_vec`.

## The Management Strategy/procedure, including estimation method (EM)

The management strategy (and EM) can be specified in one of two ways:

1. Using an SS model
2. Using a custom procedure via a function in R

In theory, any management strategy should work, as long as it can take the data file produced by the OM as output and provide back to SSMSE future catches.

### Specify the Management Strategy in a SS model

A stock synthesis model can be set up as the Estimation Method for the MSE. To use this option, specify `"EM"` as part of `MS_vec`. As with the OM, the built-in cod model could be used; just specify `"cod"` in the `EM_name_vec`. To use any other SS model as the EM, specify the path in `EM_in_dir_vec`.

Future catches will be determined from the forecasting file settings of the Stock Sythesis model. SSMSE will change the number of forecast years to match the number of years between assessments, but other specifications need to be made by the user.


### Using a custom management strategy/procedure

Users can outline a custom managment strategy as an R function to use. As long as the correct inputs and outputs are used, any estimation method and management procedure can be used. For example, here is a simple function that just sets future catches as half the sampled catches in a specified year:

```{r eval=FALSE}
constant_catch_MS <<- function(OM_dat, nyrs_assess, catch_yr = 100, 
                              frac_catch = 0.5, ...) { # need to include ... to allow function to work
  # set catch the same as the previous year (sampled catch).
  # catch is in the same units as the operating model, in this case it is in
  # biomass.
  catch <- data.frame(
    year = (OM_dat$endyr + 1):(OM_dat$endyr + nyrs_assess), # the years to project the model forward
    seas = 1, # hard coded from looking at model 
    fleet = 1,  # hard coded from looking at model
    catch = OM_dat$catch[OM_dat$catch$year == catch_yr, "catch"]*frac_catch,
    catch_se = 0.05) # hard coded from looking at model
  catch_bio <- catch # catch in biomass. In this case, catch is in biomass for both. Could also be left as NULL
  catch_F <- NULL # catch in terms of F, can be left as NULL.
  discards <- NULL # discards can be left as NULL if there are no discards
  catch_list <- list(catch = catch,
                     catch_bio = catch_bio, 
                     catch_F = catch_F,
                     discards = discards)
}
```

This function can then be used in a call to `run_SSMSE()`:

```{r eval=FALSE}
# define sample structure
datfile <- system.file("extdata", "models", "cod", "ss3.dat", package = "SSMSE")
sample_struct <- create_sample_struct(dat = datfile, nyrs = 6) # note warning
sample_struct$lencomp <- NULL # don't use length sampling

# run the SSMSE routine
run_result_custom <- run_SSMSE(
                              scen_name_vec = "constant-catch",
                              out_dir_scen_vec = "my_results",
                              iter_vec = 1,
                              OM_name_vec = "cod",
                              OM_in_dir_vec = NULL,
                              MS_vec = "constant_catch_MS", # use custom fun
                              use_SS_boot_vec = TRUE,
                              nyrs_vec = 6,
                              nyrs_assess_vec = 3,
                              rec_dev_pattern = "rand", 
                              scope = "2",
                              impl_error_pattern = "none", 
                              run_EM_last_yr = FALSE,
                              run_parallel = FALSE,
                              sample_struct_list = list(sample_struct),
                              seed = 12345)
```

## Sampling options

Currently, the only available sampling option is to use the bootstrapping module within SS itself. This means specifying `use_SS_boot_vec = TRUE`. Details on how sampling is done using the bootstrapping module in SS is available in the "Bootstrap Data Files" section of the [SS user manual](https://vlab.ncep.noaa.gov/web/stock-synthesis/document-library/-/document_library/0LmuycloZeIt/view_file/11684231).

Users also need to specify how and which data types should be sampled for each future year in the simulation in `sample_struct_list`. `sample_struct_list` is a list of lists. The first level is a list for each scenario; then, for the scenario, there is a list of dataframes, each of which specifying which years and fleets of data should be sampled in the future as well as which standard errors or sample sizes should be used.

The helper function `create_sample_struct()` can be used to help users generate the list of dataframes for a scenario. See an example of this function's use in the [simple example](#sample) or by typing `?SSMSE::create_sample_struct()` into the R console.

Users can specify the sampling during the historical period of the model through the `sample_struct_hist` input to `run_SSMSE`. This is an optional input and has the same structure as `sample_struct_list`, but the years will be before the original end year of the OM.

## Future changes to the operating model (#future)

By default, SSMSE will simply extend the structure of the OM into the future using the same parameter values as in the last year of the model. However, the user may want to allow changes in parameter values to occur as the OM is extended forward in time. Users can input values into the `future_om_list` to accomplish this. This input is a list of lists. For the first level of lists, each represents a separate change to make. Within the first level, there are 4 list components that outline the details of the change to make. There are 2 main choices: 1) to specify model changes by telling SSMSE how values should be sampled or 2) to input your own custom values for future values of a given parameter. 

### The strucutre of `future_om_list`

For example, here is an example list containing just one future change for the model. It shows that the model should be changed to 4.5 in year 103 and afterwards:

```{r}
my_future_om_list <- create_future_om_list(list_length = 1)
my_future_om_list
length(my_future_om_list) # note has length 1 b/c 1 change
length(my_future_om_list[[1]]) # has length 4 because 4 list components, as for each change

```

Note there is just one change specified here. For the change, there are four list items that are required for any specified change. 

1. The first list item is named "pars". It contains a vector of parameter name(s) to apply the change to. The names should be the same as the names in `r4ss::SS_read_pars()` or can include the following:

* `"rec_devs"` - For specifying recruitment deviations
* `"impl_error` - For specifying implementation error in transforming a management procedure's specified future catch into realized catch.
* `"all"` - Apply the change to all parameters in the model, with the exception of "SR_sigmaR", "SR_regime", "SR_autocorr", and "impl_error" parameters. Changing the first 3 stock recruitment related parameters would conflict with changes in recruitment deviations. Since implementation error  is not a parameter specified in the control file and SSMSE does not rely on the implementation error parameter created through the forecasting file, including the implementation error in "all" did not seem necessary.

In this case, we just want to apply the change to the `SizeSel_P_3_Fishery(1)` parameter of the model.

2. The second item is "scen", which contains a vector of information about how to apply the changes within and across scenarios. The first value is an option to specify how the change should be applied across scenario, either "randomize" (use a different value for each iteration of each scenario) or "replicate" (use the same set of values across scenarios for the same number iteration, but each value will be different across iterations within the same scenario). Note that the same values will be applied across iterations and scenarios if there isn't any stochasticity in the values being drawn (e.g., standard deviation set at 0), regardless if "randomize" or "replicate" is chosen. In the example above, there is no stochasticity, so specifying randomize or replicat does not matter. Following the first value are the names of the scenarios to apply the change to. If the change should be applied to scenarios, "all" can be used in place of naming every scenario. In this example, The change will only be applied to the scenario named "scen2", so the input for "scen" is `c("randomize", "scen2")`.

3. The "pattern" is a vector of character inputs. The first value should be either "model_change", meaning that SSMSE will calculate the change values, or "custom" which allows the user to directly put in the values that they want in the model. In this case, "model_change" is used. A second input can also be added when the "model_change" pattern is used, which specifies the distribution to pull from. This could be "normal" or "lognormal", but if no input is provided, a normal distribution will be used for sampling.

4. The fourth item, named "input", is a dataframe, which contains different column name values depending on if the "model_change" pattern is used or if the "custom" pattern is used. For the model_change options, a dataframe in input specifies a change for the parameter of a distribution. Because we are using the model change option, we have the following columns:
* `first_yr_averaging`: The first year to average historical values from the model, if using for the change (`NA` in our example)
* `last_yr_averaging`: The last year to average historical values from the model, if using for the change (`NA` in our example)
* `last_yr_orig_val`: The last year of the future deviations with the original model value. This value will not be changed, but the following year's value will be.
* `first_yr_final_val`: The first year where the final value as specified will be reached. If no future changes are made, the final value will continue forward in the OM through all projected years. For step changes, the `first_yr_final_val` is just 1 year after the `last_yr_orig_val`. However, if a more gradual adjustment toward the final value is desired, this could be any number of years after the original value.
* ts_param: The sampling parameter to modify. Options are "mean", "ar_1_phi" (if using autocorrelation), "sd", and "cv". If not included in the dataframe, "mean" is assumed to be the same as in the previous model year, sd is assumed to be 0, and we assume no autocorrelation (as specified through an autoregressive AR1 process). Phi should be between -1 and 1 (this creates a stationary process) and if phi = 1, this creates a random walk (as random walk is a special case of an AR1 model). Note that both sd and cv cannot be specified within the same input dataframe.
* method: How to apply the change relative to the historical (if specified) or previous year's value (if first_yr_averaging and last_yr_averaging for that row are NA). Options are "multiplicative", "additive", and "absolute". This example uses "absolute", meaning that the number in "value" is directly used.
* value. The value of the parameter change.

### Example of future_om_list denoting a gradual change

Suppose we wanted to change the value of "SizeSel_P_3_Fishery(1)" in scen2 over 4 years after year 102 to arrive at a value of 4.5 in year 106. We can do this by using `my_future_om_list`, but changing the value in the first row of `first_yr_final_val` to 106:

```{r}
my_future_om_list[[1]][["input"]][1, "first_yr_final_val"] <- 106
my_future_om_list[[1]]
```

### Example of future_om_list with a random jitter

Suppose we now wanted the value of "SizeSel_P_3_Fishery(1)" to change randomly according to a normal distribution with a standard deviation of 0.1 around a mean of 4.5 from 104 onwards. This can be done by adding a line specifying a change in standard deviation (which for now, has been assumed to be 0) to the data frame: 

```{r}
new_vals <- data.frame(first_yr_averaging = NA,
                       last_yr_averaging  = NA, 
                       last_yr_orig_val   = 103,
                       first_yr_final_val = 104, 
                       ts_param = "sd", 
                       value = 0.1)

my_future_om_list[[1]][["input"]] <- rbind(my_future_om_list[[1]][["input"]],
                                           new_vals)
my_future_om_list[[1]]
```
Note that the `last_yr_orig_val` and `first_yr_final_val` are different than the line for the mean, which is allowed.

### Example of using historical values for determining parameter values

This example applies a random jitter to all parameters for scenarios scen2 and  scen3.

```{r}

future_om_list_2 <- vector(mode = "list", length = 1)
future_om_list_2 <- lapply(future_om_list_2, function (x) x <- vector(mode = "list", length = 4))
names(future_om_list_2[[1]]) <- c("pars", "scen", "pattern", "input")

future_om_list_2[[1]][["pars"]] <- "all"
future_om_list_2[[1]][["scen"]] <- c("randomize", "scen2", "scen3")
future_om_list_2[[1]][["pattern"]] <- "model_change" # defaults to using normal dist
future_om_list_2[[1]][["input"]] <- data.frame(first_yr_averaging = c(1, 1),
                                               last_yr_averaging = c(100, 100),
                                               last_yr_orig_val = c(100, 100),
                                               first_yr_final_val = c(101, 101), 
                                               ts_param = c("cv", "mean"),
                                               method = c("absolute", "multiplier"), 
                                               value = c(0.1, 1))
```

Note that the choice of year range for historical values does not matter unless the parameter is already time-varying in the original operating model or has become time varying through a previous change. Otherwise, the base model parameter will be applied. If no historical years are included, then the base parameter value will be the basis of comparison for relative changes (i.e., method = multiplier or additive).


### Example using "custom" pattern instead of "model_change"

```{r}
custom_future_om_list <- create_future_om_list(example_type = "custom", 
                                               list_length = 1)
custom_future_om_list

```

The parameters are similar to using `pattern = model_change`, but there is no need to specify a distribution as the second vector input of "pattern" and the column names in input are different. Also that the change is "randomized", which indicates that a value for each scenario and each iteration are necessary, whereas if the first value of "scen" was "replicate", separate values for each scenario should not be specified, but rather a single value for "all" should be used. The columns in the dataframe are:

* par: the parameter name or "all" if it should be applied to all parameters in the "pars" input
* scen: which scenario the value should apply to, or "all" if "replicate" is used as the scenario input
* iter: which number iteration the value should apply to. These are absolute iteration numbers.
* yr: the year the value applies to. These should be after the original end year of the OM.
* value: the value to apply to the model

### How is the operating modified to accomodate changes as specified in the future_OM_list?

All changes are made by converting the parameter(s) with changes to be time varying by using additive parameter deviations. Because this is an operating model, Stock Synthesis is not run with estimation, so to get the changes into the OM, values (drawn or calculated in model_changes or specified by the user using "custom") are directly input as parameter deviations into the par file. 

If an OM already contains time varying parameters, these parameters will also be converted to additive parameter deviations before applying the changes specified in the future_OM_list.

<!-- ## Recruitment deviations -->

<!-- *Note: this approach will soon be replaced with a more comprehensive approach for all future changes in the operating model* -->

<!-- Future recruitment deviations to use in the simulation needs to be specified by the user. SSMSE can generate the recruitment deviations or users can specify them. The recruitment deviation pattern options (specified through `rec_dev_pattern`) are: -->

<!-- - `"none"`: All future deviations set to 0. -->
<!-- - `"rand"`: Assign normally distributed random recruitment deviations. `rec_dev_pars` needs to be considered as well when using this option. If `rec_dev_pars = NULL`, then SSMSE will default to using the same standard deviation as the historic operating model and the sum of the recruitment deviations is allowed to diverge from zero is the nyrs_assess (rec_dev_pars = NULL is the same as specifying rec_dev_pars = c(nyrs_assess, 1), If other settings are deisred, the user can input a vector of two values to rec_dev_pars to specify the max number of years over which the sum of rec_devs can diverge from zero and a scalar multiplyer of standard deviation relative to the historic OM. -->
<!-- - `"AutoCorr_rand"`: Automatically calculates random auto-correlated rec-devs based on the distribution of historic deviations. Input a vector of two values to rec_dev_pars to specify the max number of years over which the sum of rec_devs can diverge from zero and a scalar multiplyer of standard deviation relative to the historic OM. if rec_dev_pars=NULL defaults to c(nyrs_assess, 1) -->
<!-- - `"AutoCorr_Spec"`: Generates auto-correlated recruitment deviations from an MA time-series model with user specified parameters. -->
<!-- - `"user"`: The user can specify a vector or (for multiple scenarios or iterations) matrix of recruitement deviations. This input should have the same length as `nyrs` for the scenario. The vector or matrix is specified in `rec_dev_pars`. -->

<!-- *In the future, some example specifications will be shown here to better illustrate the options* -->

<!-- ## Implementation error -->

<!-- *Note: this approach will soon be replaced with a more comprehensive approach for all future changes in the operating model* -->

<!-- Management strategies that specify a total allowable catch are not always implemented perfectly. Thus, there are options in SSMSE to specify implementation error, where the true catch does not perfectly match the catch forecasted from the management strategy. The user can specify the future implementation error by using `impl_error_pattern`. Options are: -->

<!-- - `"none"` (the default) - Assume there is no implementation error. -->
<!-- - `"rand"` -  automatically assign achieved catch relative to expected catch as log normally distributed. Input a vector of `((nseas x nfleet x 2)+ 1)` values to impl_error_pars to specify the max number of years over which the achieved mean catch can diverge from the mean specified, the mean (default 1 such that achieved=expected), and the standard devation. If `impl_error__pars = NULL`, defaults to `c(nyrs_assess, rep(1,(nfleetxnseas)), rep(0,(nfleetxnseas)))`. -->
<!-- - `"user"` - applys a user input vector or matrix of implementation errors of length/columns equal to nyrs x nseas x Nfleets and rows based on assigned scope. Input the vector/matrix to `impl_error_pars`. -->

<!-- *In the future, some example specifications will be shown here to better illustrate the options* -->