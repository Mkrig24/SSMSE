% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runSSMSE.R
\name{run_SSMSE}
\alias{run_SSMSE}
\title{run an MSE using SS OMs}
\usage{
run_SSMSE(
  scen_name_vec,
  out_dir_scen_vec = NULL,
  iter_vec,
  OM_name_vec = NULL,
  OM_in_dir_vec = NULL,
  EM_name_vec = NULL,
  EM_in_dir_vec = NULL,
  MS_vec = c("EM", "no_catch"),
  use_SS_boot_vec = TRUE,
  nyrs_vec,
  nyrs_assess_vec,
  scope = c("2", "1", "3"),
  rec_dev_pattern = c("none", "rand", "AutoCorr_rand", "AutoCorr_Spec", "vector"),
  rec_dev_pars = NULL,
  impl_error_pattern = c("none", "rand", "user"),
  impl_error_pars = NULL,
  sample_struct_list = NULL,
  interim_struct_list = NULL,
  verbose = FALSE,
  seed = NULL,
  run_parallel = FALSE,
  n_cores = NULL
)
}
\arguments{
\item{scen_name_vec}{A vector containing names of the scenarios. The each
string will be a directory containing all the model runs for a scenario.s}

\item{out_dir_scen_vec}{The directory to which to write output. IF NULL, will
default to the working directory.}

\item{iter_vec}{The number of iterations per scenario. A vector of integers
in the same order as scen_name_vec.}

\item{OM_name_vec}{Name of a valid Stock Synthesis stock assessment model from
which to create the OM. Currently, only allows models in the package, so
valid inputs are: \code{"cod"}.}

\item{OM_in_dir_vec}{Vector of relative or absolute paths to the operating
model, if using a model outside of the SSMSE package.}

\item{EM_name_vec}{Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
Synthesis stock assessment model to use as an EM. If the value of EM_name
is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
in the path specified in EM_in_dir. valid inputs for EM_name are: \code{"cod"}
 or \code{NULL}.}

\item{EM_in_dir_vec}{Relative or absolute path to the estimation model, if using
model outside of the SSMSE package. Note that this value should be NULL if
\code{MS} has a value other than "EM".}

\item{MS_vec}{Vector of management strategies.}

\item{use_SS_boot_vec}{Should a bootstrapped data set generated by SS be used?
Defaults to TRUE.}

\item{nyrs_vec}{Number of years beyond the years included in the OM to run the
MSE. A single integer value.}

\item{nyrs_assess_vec}{The number of years between assessments. E.g., if an
assessment is conducted every 3 years, put 3 here. A single integer value.
(NOTE: This could be made more flexible by instead reading in a vector of
assessment years, so users could specify irregular numbers of yrs between
assessments.)}

\item{scope}{Assign the scope of random deviations for rec devs and implementation error.
single integer value input where 1=values are identical across all scenarios and iterations
(if rec_dev_pattern=user input a vector of length nyrs_vec), 2 (default)=values are random
across iterations but the same iterations are used across scenarios
(if rec_dev_pattern=user input a matrix with ncols=nyrs_vec and nrows=number of iterations),
3=values are random across all iterations and scenarios (if rec_dev_pattern=user input
a matrix with ncols=nyrs_vec and nrows=(number of iterations)*(number of scenarios)).}

\item{rec_dev_pattern}{Parameter to specify future rec devs. Input options include:
1) "none" to set all future devs to zero (default). 2) "rand" automatically assign normally
distributed random recruitment deviations. Input a vector of two values to rec_dev_pars
to specify the max number of years over which the sum of rec_devs can diverge from
zero and a scalar multiplyer of standard deviation relative to the historic OM. if
rec_dev_pars=NULL defaults to c(nyrs_assess, 1). 3) "AutoCorr_rand" automatically calculates 
random auto-correlated rec-devs based on the distribution of historic deviations. Input a vector of two values to rec_dev_pars
to specify the max number of years over which the sum of rec_devs can diverge from
zero and a scalar multiplyer of standard deviation relative to the historic OM. if
rec_dev_pars=NULL defaults to c(nyrs_assess, 1). 4) "AutoCorr_Spec" 
generates auto-correlated recruitment deviations from an MA time-series model with user specified
parameters. 5) "user" applys a user input vector or matrix of recruitement deviations of 
length equal nyrs input the vector/matrix to rec_dev-pars.}

\item{rec_dev_pars}{Input the required parameters as specified by rec_dev_pattern choice.}

\item{impl_error_pattern}{Parameter to specify future implementation error. Input options include:
1) "none" to set all future catches equal to expected (default). 2) "rand" automatically assign
achieved catch relative to expected catch as log normally distributed. Input
a vector of ((nseas x nfleet x 2)+ 1) values to impl_error_pars to specify the max number
of years over which the achieved mean catch can diverge from the mean specified, the mean
(default 1 such that achieved=expected), and the standard devation. If impl_error__pars=NULL defaults to
c(nyrs_assess, rep(1,(nfleetxnseas)), rep(0,(nfleetxnseas))). 3) "user" applys a user input vector
or matrix of implementation errors of length/columns equal to nyrs x nseas x Nfleets
and rows based on assigned scope. Input the vector/matrix to impl_error_pars.}

\item{impl_error_pars}{Input the required parameters as specified by impl_error_pattern choice.}

\item{sample_struct_list}{A optional list of lists including which years, seasons,
and fleets should be  added from the OM into the EM for different types of
data. If NULL, the data structure will try to be infered from the pattern
found for each of the datatypes within the EM datafiles. Include this
strucutre for the number of years to extend the model out.}

\item{interim_struct_list}{A optional list of parameters to control an interim assessment
with an example structure below, where Beta=a positive value that is inversely proportional to risk, 
MA_years= the number of years to average index observations of when calculating deviations, 
assess_freq=the number of years between full assessments during with an interim assessment will happen
every year, and Index_weights is a vector of length n indexes that weights all indexes for multi index
inference. 
interim_struct_list<-list(Beta=1,MA_years=3,assess_freq=5,Index_weights=rep(1,max(ref_index[,3])))}

\item{verbose}{Want verbose output? Defaults to FALSE.}

\item{seed}{Input a fixed seed to replicate previous simulation runs. seed can be a single value
for a global seed, n_scenarios+1 length vector for scenario specific and a global seed, 
n_iterations+n_scenarios+1 length vector for iteration scenario and global seeds. Can also be a list
object with a single value under seed$global, a vector under seed$scenario, and a multiple vectors 
for iteration specific seeds under seed$iter[[1:n_scenarios]].}

\item{run_parallel}{true false option to use parallel processing or not defaults to FALSE}

\item{n_cores}{how many cores to use if running in parallel defaults to n_cores available - 1 (also capped at n_cores available - 1)}
}
\description{
High level function to run a management strategy evaluation using Stock
Synthesis as the Operating model(s)
}
\examples{

\dontrun{
my_dir <- file.path(tempdir(), "ex-run_SSMSE")
  dir.create(my_dir)
  # For the EM, use the specified data structure
  my_sample_struct_list <- list(NULL,
                         list(
                           catch = data.frame(Yr = 101:106,
                                              Seas = 1,
                                              FltSvy = 1,
                                              SE = 0.05),
                           CPUE = data.frame(Yr = c(102, 105),
                                             Seas = 7,
                                             FltSvy = 2, 
                                             SE = 0.01), 
                          lencomp = data.frame(Yr = c(102, 105), Seas = 1, 
                                               FltSvy = 1, Sex = 0,
                                               Part = 0, Nsamp = 100),
                            )
                        )
  # Use the default parameter values, except for the once specified.
  # Note that the scen_list, either specified or internally created in the
  # function is returned.
  input_list <- run_SSMSE(
                          scen_name_vec = c("scen_1", "scen_2")
                          out_dir_scen_vec = my_dir,
                          iter_vec = c(2, 2),
                          OM_name_vec = c("cod","cod"),
                          OM_in_dir_vec = NULL,
                          EM_name_vec = c(NA, "cod"),
                          EM_in_dir_vec = NULL,
                          MS_vec = c("no_catch", "EM"),
                          use_SS_boot_vec = TRUE,
                          nyrs_vec = 6,
                          nyrs_assess_vec = 3,
                          scope = c("2", "1", "3"),
                          rec_dev_pattern = c("none", "rand", "AutoCorr_rand",
                                                "AutoCorr_Spec", "vector"),
                          rec_dev_pars = NULL,
                          impl_error_pattern = c("none", "rand", "user"),
                          impl_error_pars = NULL,
                          verbose = FALSE,
                          seed=NULL,
                          sample_struct_list = my_sample_struct_list)
  unlink(my_dir, recursive = TRUE)
}
}
\author{
Kathryn Doering & Nathan Vaughan
}
