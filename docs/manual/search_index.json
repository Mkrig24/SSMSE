[
["index.html", "SSMSE user manual Preface R session information", " SSMSE user manual Kathryn Doering and Nathan Vaughan 2020-11-09 Preface This is the user manual for SSMSE, an R package for Management Strategy Evaluation with Stock Synthesis Operating models. Note this documentation is still a work in progress! R session information sessionInfo() ## R version 4.0.2 Patched (2020-07-15 r78861) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_United States.1252 LC_CTYPE=English_United States.1252 ## [3] LC_MONETARY=English_United States.1252 LC_NUMERIC=C ## [5] LC_TIME=English_United States.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] r4ss_1.40.1 ss3sim_1.1.3 "],
["intro.html", "1 Introduction 1.1 Purpose 1.2 Functions in SSMSE 1.3 Brief description of the SSMSE MSE simulation procedure", " 1 Introduction 1.1 Purpose SSMSE was developed to increase the ease of using Stock Synthesis (SS) directly as an operating model in an Management Strategy evaluation. The approach requires a conditioned Stock Synthesis model, which is treated as the Operating Model and a Stock Synthesis model to use as the Estimation Model (EM) and to specify the Management procedure through the Stock Synthesis forecasting model. 1.2 Functions in SSMSE The functions users can call in SSMSE are: Function Description run_SSMSE Run the MSE simulations create_sample_struct Helper function to create a list for future sampling from a model to use as input in run_SSMSE develop_OMs Helper function to turn one OM into many SSMSE_summary_all Summarize MSE output 1.3 Brief description of the SSMSE MSE simulation procedure 1.3.1 Conditioning the OM and sampling from the OM For each scenario, SSMSE starts with the user providing a fitted Stock Synthesis model (or selecting an model from the SSMSE package) to use as an OM. For each iteration of the scenario, SSMSE turns the SS fitted model into an OM and runs it once with no estimation with Stock Synthesis in order to get the “true” values and a bootstrapped data set from SS. 1.3.2 First run of the management strategy in the MSE simulation The bootstrapped dataset is then used in a Management strategy to forecast catch for the next n years. 1.3.3 Feedback from Managment Strategy into OM: extending model years The catch for the next n years before the next assessment is then added to the OM, as well as any recruitment or time varying parameter deviations. The OM is then projected forward n years and run with no estimation where it can be used to produce sampled data for the next n years. These new data values are appended to the original dataset. 1.3.4 Subsequent runs of the management strategy The appended data set is then used in the managment strategy again. New forecasts are produced, and are fed back to the OM. "],
["simple.html", "2 A simple example 2.1 Setup R workspace folders 2.2 Create the operating models (OMs) 2.3 Examine the management procedure used 2.4 Adding observation error: Specify how to sample data from the Operating model (#sample) 2.5 Adding process error through recruitment deviations 2.6 Run SSMSE 2.7 run_SSMSE output 2.8 Performance metrics 2.9 Summarize results 2.10 Example MSE Results 2.11 Delete the files", " 2 A simple example We will start off exploring SSMSE by running a simple example. Suppose we want to look at how well we are able to achieve a specified management procedure under uncertainty in the operating model (OM). We will look 2 scenarios, one where Steepness (h) is specified correctly and one where it is specified incorrectly in an estimation model (EM): Scenario 1. h-ctl: Cod operating model (h = 0.65) with correctly specified cod model EM (fixed h = 0.65). The OM is the same as the EM. Scenario 2. h-1: Cod operating model (h = 1) with misspecified cod model EM (fixed h = 0.65); The OM is not the same as the EM. Note that this is a simple example where the OM and EM structures for both scenarios are identical, except for different steepness between the OM and EM in scenario 2. We will assume we want to run the MSE loop for 6 years, with a stock assessment occuring every 3 years (and forecasting catch to maintain 40% of unfished spawning stock biomass). The cod model’s last year is 100, so the OM is initially conditioned through year 100. Then, after conditioning the operating model through year 100, assessments will occur in years 100 and 103. The operating model runs through year 106. We chose not to run the assessment in year 106, as there was no need for its output in this example. 2.1 Setup R workspace folders First, we will load the SSMSE package and create a folder in which to run the example: library(SSMSE) #load the package ## Warning: replacing previous import &#39;vctrs::data_frame&#39; by &#39;tibble::data_frame&#39; when loading &#39;dplyr&#39; library(r4ss) #install using remotes::install_github(&quot;r4ss/r4ss@development) library(foreach) #if using run_parallel = TRUE library(doParallel) #if using run_parallel = TRUE ## Loading required package: iterators ## Loading required package: parallel # Create a folder for the output in the working directory. run_SSMSE_dir &lt;- file.path(&quot;run_SSMSE-ex&quot;) dir.create(run_SSMSE_dir) 2.2 Create the operating models (OMs) The cod model with h = 0.65 (as in scenario 1) is included as external package data in SSMSE. However, we will need to modify it to use as an operating model with h = 1 (as in scenario 2). Note in this case that refit_OM is false, so the model is not being refit, just run through without fitting. To condition the new model on the same data as the input model, refit_OM should be TRUE. First, we identify where the base cod model is stored, modify it such that the steepness parameter is 1, and save the modified cod OM for scenario 2 in a new folder in the run_SSMSE_dir directory. cod_mod_path &lt;- system.file(&quot;extdata&quot;, &quot;models&quot;, &quot;cod&quot;, package = &quot;SSMSE&quot;) # develop_OMs will save a model called &quot;cod_SR_BH_steep_1&quot; in the out_dir # specified develop_OMs(OM_name = &quot;cod&quot;, out_dir = run_SSMSE_dir, par_name = &quot;SR_BH_steep&quot;, par_vals = 1, refit_OMs = FALSE, hess = FALSE) # OM model for scenario 2 cod_1_path &lt;- file.path(run_SSMSE_dir, &quot;cod_SR_BH_steep_1&quot;) 2.3 Examine the management procedure used We will use the same management procedure for both scenarios: Conduct a stock assessment every 3 years to get stock status. Forecast from this stock assessment using the SS forecast file to get future catch. Put this forecasted catch (without implementation error, in the case of this example) back into the OM. Extend the OM forward in time to get the true values for the population. Let’s take a look at step 2 in the management procedure, which is implemented using the forecasting module in SS. We will examine the forecast file for the estimation model to better understand how catches will be forecasted from the assessment. We will use the same management procedure in both of these scenarios, although for a full MSE analysis, it is likely that multiple management procedures would be compared. fore &lt;- r4ss::SS_readforecast( system.file(&quot;extdata&quot;, &quot;models&quot;, &quot;cod&quot;, &quot;forecast.ss&quot;, package = &quot;SSMSE&quot;), verbose = FALSE) fore$Forecast ## [1] 3 fore$Btarget ## [1] 0.4 fore$Forecast = 3 means our forecasts from the assessment will use fishing mortality (F) to achieve a relative (to unfished) spawning stock biomass. Based on fore$Btarget, the relative biomass target is 40% of unfished spawning stock biomass. Note also that the control rule fore$BforconstantF and fore$BfornoF values are set low to make it unlikely that they will be used (these parameters are used for a ramp harvest control rule, which we do not want to use here): fore$BforconstantF ## [1] 0.03 fore$BfornoF ## [1] 0.01 Futhermore, fore$Flimitfraction is set to 1 so that the forecasted catch is set equal to the overfishing limit (for simplicity): fore$Flimitfraction ## [1] 1 Note that the number of forecast years is 1: fore$Nforecastyrs ## [1] 1 However, an assessment will be conducted every 3 years and 3 years of forecasting is required. SSMSE will modify this value to the appropriate number of forecasting years. More information on using the forecast module in SS to forecast catches is available in the Stock Synthesis users manual. 2.4 Adding observation error: Specify how to sample data from the Operating model (#sample) The argument sample_struct specifies the structure for sampling from the OM (and passing to the EM). The function create_sample_struct can be used to construct a simple sampling structure consistent with an input data file: datfile &lt;- system.file(&quot;extdata&quot;, &quot;models&quot;, &quot;cod&quot;, &quot;ss3.dat&quot;, package = &quot;SSMSE&quot;) sample_struct &lt;- create_sample_struct(dat = datfile, nyrs = 6) # note warning ## Warning in FUN(X[[i]], ...): Pattern not found for lencomp: FltSvy 1, Seas 1. Returning NA for Yr in this ## dataframe. sample_struct ## $catch ## Yr Seas FltSvy SE ## 1 101 1 1 0.005 ## 2 102 1 1 0.005 ## 3 103 1 1 0.005 ## 4 104 1 1 0.005 ## 5 105 1 1 0.005 ## 6 106 1 1 0.005 ## ## $CPUE ## Yr Seas FltSvy SE ## 1 105 7 2 0.2 ## ## $lencomp ## Yr Seas FltSvy Sex Part Nsamp ## 1 NA 1 1 0 0 125 ## ## $agecomp ## Yr Seas FltSvy Sex Part Ageerr Lbin_lo Lbin_hi Nsamp ## 1 105 1 2 0 0 1 -1 -1 500 By default, create_sample_struct identifies sampling patterns from the historical period of the OM and replicates those patterns in the projection period. In our cod example, the sample structure specifies that catch will be added to the estimation model every year (years 101 to 106), but an index of abundance (i.e., CPUE) and age composition (i.e., agecomp) will only be added in year 105. We will use the same sampling scheme for both scenarios, but it is possible to specify different sampling for each scenario. The user could modify this sampling strategy (for example, maybe age composition should also be sampled from FltSvy 2 in Yr 102; the user could add another line to the dataframe in sample_struct$agecomp). Note that length comp (lencomp) includes an NA value for year. This is because no consistent pattern was identified, so the user must define their own input. In this case, we will remove sampling length comps all together: sample_struct$lencomp &lt;- NULL # don&#39;t use length sampling The same sampling structure will be used for both scenarios, which we define in a list below: sample_struct_list &lt;- list(&quot;h-ctl&quot; = sample_struct, &quot;h-1&quot; = sample_struct) 2.5 Adding process error through recruitment deviations Process error can be added through the recruitment deviations. In this case, rec_dev_pattern = \"rand\" in the call to run_SSMSE is used to use random recruitment deviations with the same standard deviation as the historical recruitment deviation pattern. Set scope = 2 so that the same recruitment deviation patterns are used across scenarios, but different patterns are use across iterations in the same scenario. For more information on the available options for rec_dev_pattern and scope please see the documentation for the run_SSMSE function (?SSMSE::run_SSMSE). 2.6 Run SSMSE Now, we create a directory to store our results, and use run_SSMSE to run the MSE analysis loop (note this will take some time to run, ~ 20 min): run_res_path &lt;- file.path(run_SSMSE_dir, &quot;results&quot;) dir.create(run_res_path) run_SSMSE(scen_name_vec = c(&quot;h-ctl&quot;, &quot;h-1&quot;),# name of the scenario out_dir_scen_vec = run_res_path, # directory in which to run the scenario iter_vec = c(5,5), # run with 5 iterations each OM_name_vec = NULL, # specify directories instead OM_in_dir_vec = c(cod_mod_path, normalizePath(cod_1_path)), # OM files EM_name_vec = c(&quot;cod&quot;, &quot;cod&quot;), # cod is included in package data MS_vec = c(&quot;EM&quot;,&quot;EM&quot;), # The management strategy is specified in the EM use_SS_boot_vec = c(TRUE, TRUE), # use the SS bootstrap module for sampling nyrs_vec = c(6, 6), # Years to project OM forward nyrs_assess_vec = c(3, 3), # Years between assessments rec_dev_pattern = &quot;rand&quot;, # Use random recruitment devs scope = &quot;2&quot;, # to use the same recruitment devs across scenarios. impl_error_pattern = &quot;none&quot;, # Don&#39;t use implementation error run_EM_last_yr = FALSE, # Run the EM in 106 run_parallel = TRUE, # Run iterations in parallel sample_struct_list = sample_struct_list, # How to sample data for running the EM. seed = 12345) #Set a fixed integer seed that allows replication See ?run_SSMSE for more details on function arguments. In a real MSE analysis, running 100+ iterations to reflect the full range of uncertainty (given observation and process errors) in the results would be preferred. However, we are only running 5 iterations per scenario in this demonstration to reduce computing time. 2.7 run_SSMSE output run_SSMSE will create new folders in the folders specified in out_dir_scen_vec (note that in this case, we are running both scenarios in the same folder). After is complete, there will be a folder for each scenario in run_res_path (since out_dir_scen_vec = run_res_path in this example): list.dirs(run_res_path, recursive = FALSE) ## [1] &quot;run_SSMSE-ex/results/h-1&quot; &quot;run_SSMSE-ex/results/h-ctl&quot; Within each scenario is a folder for each scenario: # See folders for scenario 1. list.dirs(file.path(run_res_path, &quot;h-ctl&quot;), recursive = FALSE) ## [1] &quot;run_SSMSE-ex/results/h-ctl/1&quot; &quot;run_SSMSE-ex/results/h-ctl/2&quot; ## [3] &quot;run_SSMSE-ex/results/h-ctl/3&quot; &quot;run_SSMSE-ex/results/h-ctl/4&quot; ## [5] &quot;run_SSMSE-ex/results/h-ctl/5&quot; And within each scenario folder, there are folders containing the SS models that were run by run_SSMSE. # see folders for the first iteration of scenario 1 list.dirs(file.path(run_res_path, &quot;h-ctl&quot;, &quot;1&quot;), recursive = FALSE) ## [1] &quot;run_SSMSE-ex/results/h-ctl/1/cod_EM_103&quot; ## [2] &quot;run_SSMSE-ex/results/h-ctl/1/cod_EM_init&quot; ## [3] &quot;run_SSMSE-ex/results/h-ctl/1/cod_OM&quot; There should be 1 folder for the OM, which is run multiple times in this same folder during the MSE analysis. There are multiple folders for the EMs, as a new folder is created each time an assessment is done. The first run is the folder with a name ending in init; then, each assessment after is named for the updated end year of the model. With many iterations, the number of files adds up; in the future, we hope to add options to save less output. 2.8 Performance metrics Quantitative performance metrics should be specified before conducting an MSE. Typically, a suite of performance metrics will be examined; however, for simplicity in this example, we will only look at what the achieved relative biomass was for the last 3 years of projection in the MSE to determine how it compares to the intended management target of 40% of unfished Spawning Stock Biomass. Note that we are only running our MSE projection for 6 years, but longer projections are typical in MSE analyses. 2.9 Summarize results The function SSMSE_summary_all can be used to summarize the model results in a list of 3 dataframes, one for scalar outputs (named scalar), one for timeseries outputs (ts), one for derived quantities (dq). This function also creates summary csv files in the folder where the results are stored. # Summarize 1 iteration of output summary &lt;- SSMSE_summary_all(run_res_path) ## Extracting results from 2 scenarios ## Starting h-1 with 5 iterations ## Starting h-ctl with 5 iterations Plotting and data manipulation can then be done with these summaries. For example, SSB over time by model can be plotted. The models include the Operating Model (cod_OM), Estimation model (EM) for the historical period of years 0-100 (cod_EM_init), and the EM run with last year of data in year 103 (cod_EM_103). The operating models are shown in blue or black (depending on the scenario), and the estimation model runs are shown in orange, and the scenarios are shown on different subplots: library(ggplot2) # use install.packages(&quot;ggplot2&quot;) to install package if needed library(tidyr) # use install.packages(&quot;tidyr&quot;) to install package if needed library(dplyr) # use install.packages(&quot;dplyr&quot;) to install package if needed ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # plot SSB by year and model run ggplot2::ggplot(data = subset(summary$ts, model_run %in% c(&quot;cod_OM&quot;, &quot;cod_SR_BH_steep_1_OM&quot;, &quot;cod_EM_103&quot;)), ggplot2::aes(x = year, y = SpawnBio)) + ggplot2::geom_vline(xintercept = 100, color = &quot;gray&quot;) + ggplot2::geom_line(ggplot2::aes(linetype = as.character(iteration), color = model_run))+ ggplot2::scale_color_manual(values = c(&quot;#D65F00&quot;, &quot;black&quot;, &quot;blue&quot;)) + ggplot2::scale_linetype_manual(values = rep(&quot;solid&quot;, 50)) + ggplot2::guides(linetype = FALSE) + ggplot2::facet_wrap(. ~ scenario) + ggplot2::theme_classic() This plot shows that SSB estimated does not match perfectly with the operating model. A similar plot could be made for anu parameter of interest. Now, we calculate and plot the performance metric. # The get_rel_SSB_avg calculates the relative SSB in each year for each # iteration of the operating model, then takes the average over the years from # min_yr, to max_year. It uses the summary object as input to do these # calculations. get_rel_SSB_avg &lt;- function(summary, min_yr, max_yr) { # Get just the result for the OMs and not for the EMs. OM_vals &lt;- unique(summary$ts$model_run) OM_vals &lt;- grep(&quot;_OM$&quot;, OM_vals, value = TRUE) # find the unfished biomass fr the OMs B_unfished &lt;- summary$scalar %&gt;% filter(model_run %in% OM_vals) %&gt;% select(iteration, scenario,SSB_Unfished) # find the spawning stock biomass for the years of interest SSB_yr &lt;- summary$ts %&gt;% filter(year &gt;= min_yr &amp; year &lt;= max_yr) %&gt;% select(iteration, scenario, year, SpawnBio) # Calculated the relative spawning stock biomass using B_unfished and SSB_yr # dataframes, then take an average over years. SSB_yr &lt;- left_join(SSB_yr, B_unfished) %&gt;% mutate(Rel_SSB = SpawnBio/SSB_Unfished) %&gt;% group_by(iteration, scenario) %&gt;% summarize(avg_SSB = mean(Rel_SSB), .groups = &quot;keep&quot;) %&gt;% ungroup() SSB_yr # return SSB averaged over yrs for each iteration and each scenario. } rel_SSB &lt;- get_rel_SSB_avg(summary, min_yr = 104, max_yr = 106) ## Joining, by = c(&quot;iteration&quot;, &quot;scenario&quot;) # function to summarize data in plot data_summary &lt;- function(x) { m &lt;- mean(x) ymin &lt;- m - sd(x) ymax &lt;- m + sd(x) return(c(y = m, ymin = ymin, ymax = ymax)) } # Now, plot the average relative spawning stock biomass for years 104 - 106 ggplot(data = rel_SSB, aes(x = scenario, y = avg_SSB)) + geom_hline(yintercept = 0.4, color = &quot;gray&quot;) + stat_summary(fun.data = data_summary, position = position_dodge(width = 0.9), color = &quot;blue&quot;) + scale_y_continuous(limits = c(0, 0.8)) + labs(title = &quot;Long-term average relative SSB\\n(years 104-106)&quot;, x = &quot;Scenario&quot;, y = &quot;SSB/SSB_unfished&quot;) + theme_classic() From the above plot, we see that the realized Spawning stock Biomass is higher than the target that was intended for both scenarios. 2.10 Example MSE Results We can see from the performance metric that mis-specifying the value of steepness will results in higher realized relative spawning stock biomass than correctly specifying it. This gives us some idea of the consequences of misspecifying steepness in the stock assessment. 2.11 Delete the files If you wish to delete the files created from this example, you can use: unlink(run_SSMSE_dir, recursive = TRUE) "],
["SSMSE.html", "3 Options for run_SSMSE 3.1 Scenarios in SSMSE 3.2 Operating model 3.3 The Management Strategy/procedure, including estimation method (EM) 3.4 Sampling options 3.5 Recruitment deviations 3.6 Implementation error", " 3 Options for run_SSMSE Many inputs are possible for the run_SSMSE option. Here, we will describe some of the options available. For detailed documentation, type ?SSMSE::run_SSMSE into the R console. 3.1 Scenarios in SSMSE Note that multiple scenarios can be called in run_SSMSE, often through vector inputs to run_SSMSE. Below, we will describe inputs needed to run 1 scenario. 3.2 Operating model The operating model (OM) for SSMSE should be a Stock Synthesis model. This could be any fitted Stock dSynthesis model. There is one built-in OM that comes with SSMSE, which is a cod-like model. To use the cod model in run_SSMSE, set OM_name_vec = \"cod\". Otherwise, the path to the OM model should be specified in OM_in_dir_vec. 3.3 The Management Strategy/procedure, including estimation method (EM) The management strategy (and EM) can be specified in one of two ways: Using an SS model Using a custom procedure via a function in R In theory, any management strategy should work, as long as it can take the data file produced by the OM as output and provide back to SSMSE future catches. 3.3.1 Specify the Management Strategy in a SS model A stock synthesis model can be set up as the Estimation Method for the MSE. To use this option, specify \"EM\" as part of MS_vec. As with the OM, the built-in cod model could be used; just specify \"cod\" in the EM_name_vec. To use any other SS model as the EM, specify the path in EM_in_dir_vec. Future catches will be determined from the forecasting file settings of the Stock Sythesis model. SSMSE will change the number of forecast years to match the number of years between assessments, but other specifications need to be made by the user. 3.3.2 Using a custom management strategy/procedure Users can outline a custom managment strategy as an R function to use. As long as the correct inputs and outputs are used, any estimation method and management procedure can be used. For example, here is a simple function that just sets future catches as half the sampled catches in a specified year: constant_catch_MS &lt;&lt;- function(OM_dat, nyrs_assess, catch_yr = 100, frac_catch = 0.5, ...) { # need to include ... to allow function to work # set catch the same as the previous year (sampled catch). # catch is in the same units as the operating model, in this case it is in # biomass. catch &lt;- data.frame( year = (OM_dat$endyr + 1):(OM_dat$endyr + nyrs_assess), # the years to project the model forward seas = 1, # hard coded from looking at model fleet = 1, # hard coded from looking at model catch = OM_dat$catch[OM_dat$catch$year == catch_yr, &quot;catch&quot;]*frac_catch, catch_se = 0.05) # hard coded from looking at model catch_bio &lt;- catch # catch in biomass. In this case, catch is in biomass for both. Could also be left as NULL catch_F &lt;- NULL # catch in terms of F, can be left as NULL. discards &lt;- NULL # discards can be left as NULL if there are no discards catch_list &lt;- list(catch = catch, catch_bio = catch_bio, catch_F = catch_F, discards = discards) } This function can then be used in a call to run_SSMSE: # define sample structure datfile &lt;- system.file(&quot;extdata&quot;, &quot;models&quot;, &quot;cod&quot;, &quot;ss3.dat&quot;, package = &quot;SSMSE&quot;) sample_struct &lt;- create_sample_struct(dat = datfile, nyrs = 6) # note warning sample_struct$lencomp &lt;- NULL # don&#39;t use length sampling # run the SSMSE routine run_result_custom &lt;- run_SSMSE( scen_name_vec = &quot;constant-catch&quot;, out_dir_scen_vec = &quot;my_results&quot;, iter_vec = 1, OM_name_vec = &quot;cod&quot;, OM_in_dir_vec = NULL, MS_vec = &quot;constant_catch_MS&quot;, # use custom fun use_SS_boot_vec = TRUE, nyrs_vec = 6, nyrs_assess_vec = 3, rec_dev_pattern = &quot;rand&quot;, scope = &quot;2&quot;, impl_error_pattern = &quot;none&quot;, run_EM_last_yr = FALSE, run_parallel = FALSE, sample_struct_list = list(sample_struct), seed = 12345) 3.4 Sampling options Currently, the only available sampling option is to use the bootstrapping module within SS itself. This means specifying use_SS_boot_vec = TRUE. Details on how sampling is done using the bootstrapping module in SS is available in the “Bootstrap Data Files” section of the SS user manual. Users also need to specify how and which data types should be sampled for each future year in the simulation in sample_struct_list. sample_struct_list is a list of lists. The first level is a list for each scenario; then, for the scenario, there is a list of dataframes, each of which specifying which years and fleets of data should be sampled in the future as well as which standard errors or sample sizes should be used. The helper function create_sample_struct can be used to help users generate the list of dataframes for a scenario. See an example of this function’s use in the simple example or by typing ?SSMSE::create_sample_struct into the R console. 3.5 Recruitment deviations Future recruitment deviations to use in the simulation needs to be specified by the user. SSMSE can generate the recruitment deviations or users can specify them. The recruitment deviation pattern options (specified through rec_dev_pattern) are: \"none\": All future deviations set to 0. \"rand\": Assign normally distributed random recruitment deviations. rec_dev_pars needs to be considered as well when using this option. If rec_dev_pars = NULL, then SSMSE will default to using the same standard deviation as the historic operating model and the sum of the recruitment deviations is allowed to diverge from zero is the nyrs_assess (rec_dev_pars = NULL is the same as specifying rec_dev_pars = c(nyrs_assess, 1), If other settings are deisred, the user can input a vector of two values to rec_dev_pars to specify the max number of years over which the sum of rec_devs can diverge from zero and a scalar multiplyer of standard deviation relative to the historic OM. \"AutoCorr_rand\": Automatically calculates random auto-correlated rec-devs based on the distribution of historic deviations. Input a vector of two values to rec_dev_pars to specify the max number of years over which the sum of rec_devs can diverge from zero and a scalar multiplyer of standard deviation relative to the historic OM. if rec_dev_pars=NULL defaults to c(nyrs_assess, 1) \"AutoCorr_Spec\": Generates auto-correlated recruitment deviations from an MA time-series model with user specified parameters. \"user\": The user can specify a vector or (for multiple scenarios or iterations) matrix of recruitement deviations. This input should have the same length as nyrs for the scenario. The vector or matrix is specified in rec_dev_pars. In the future, some example specifications will be shown here to better illustrate the options 3.6 Implementation error Management strategies that specify a total allowable catch are not always implemented perfectly. Thus, there are options in SSMSE to specify implementation error, where the true catch does not perfectly match the catch forecasted from the management strategy. The user can specify the future implementation error by using impl_error_pattern. Options are: \"none\" (the default) - Assume there is no implementation error. \"rand\" - automatically assign achieved catch relative to expected catch as log normally distributed. Input a vector of ((nseas x nfleet x 2)+ 1) values to impl_error_pars to specify the max number of years over which the achieved mean catch can diverge from the mean specified, the mean (default 1 such that achieved=expected), and the standard devation. If impl_error__pars = NULL, defaults to c(nyrs_assess, rep(1,(nfleetxnseas)), rep(0,(nfleetxnseas))). \"user\" - applys a user input vector or matrix of implementation errors of length/columns equal to nyrs x nseas x Nfleets and rows based on assigned scope. Input the vector/matrix to impl_error_pars. In the future, some example specifications will be shown here to better illustrate the options "],
["helper.html", "4 Helper functions in SSMSE 4.1 Creating multiple operating models with develop_OMs 4.2 Set up sampling for a scenario with create_sample_struct", " 4 Helper functions in SSMSE run_SSMSE requires some detailed inputs that are time consuming to make. In the interest of automating routines as much as possible, helper functions are available in SSMSE. 4.1 Creating multiple operating models with develop_OMs This function allows users to change a parameter in a Stock Synthesis OM and, if desired, refit the operating model to data. Typically, users will want to create multiple operating models to use in different scenarios in order to account for uncertainties in parameter values, such as biological parameters relating to natural mortality or growth. 4.2 Set up sampling for a scenario with create_sample_struct run_SSMSE requires the input sample_struct, which outlines the future sampling structure to use to generate data sets. This object could be difficult to create manually and users may want to just continue sampling as previously done in an existing SS model. create_sample_struct will use the time patterns in sampling for different data types found in an SS data file and extend it forward in time. If no pattern is found, the function will return NAs and provide a warning to the user. See use of create_sample_struct in simple example. "],
["output.html", "5 Output and Plots 5.1 Summarizing output 5.2 Checking estimation model convergence 5.3 Calculating performance metrics", " 5 Output and Plots 5.1 Summarizing output Output is summarized using SSMSE_summary_all: summary_list &lt;- SSMSE_summary_all(dir = &quot;path/to/scenario/dir&quot;, scenarios = c(&quot;sample_low&quot;, &quot;sample_high&quot;), run_parallel = TRUE) Relying on ss3sim::get_results_all, this function creates: For each scenario, 3 scenario level .csv files For all scenarios, 2 cross-scenario .csv files named by default to SSMSE_tsand SSMSE_scalar. For all scenarios, the function returns a list object containing data frames of timeseries (ts), scalar, and derived quantities (dq) summaries. Note that run_parallel = TRUE is only useful when there is more than once scenario and none of the scenario-level .csv files have been created yet. By default, if a user doesn’t specify scenarios, all scenarios in dir will be summarized. 5.2 Checking estimation model convergence One of the first checks to do if using an estimation model after running an MSE analysis is to check that the estimation model has convereged. A number of checks could be done, but a pretty basic one is checking the gradients for the estimation model (not the Operating models), which are added to the SSMSE_scalar summary sheet. 5.3 Calculating performance metrics Typically, a suite of performance metrics are used in MSE. Punt et al. (2016) recommends at least using metrics related to: average catch variation in catch over time population size "],
["plotting-output-and-performance-metrics.html", "6 Plotting output and performance metrics", " 6 Plotting output and performance metrics to be added "]
]
