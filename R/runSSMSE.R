#' run an MSE using SS OMs
#' 
#' High level function to run a management strategy evaluation using Stock
#' Synthesis as the Operating model(s)
run_SSMSE <- function() {
  
}


#' Run an MSE scenario using SS OM
#' 
#' High level function to run 1 scenario (but potentially many iterations) for 
#' a management strategy evaluation using Stock Synthesis as the Operating Model
run_SSMSE_scen <- function() {
  
}

#' Run 1 iteration of an MSE using SS OM
#' 
#' High level function to run 1 iteration of a scenario for a management 
#' strategy evaluation using Stock Synthesis as the Operating model.
#' 
#' @author Kathryn Doering
#' @param OM_name Name of a valid Stock Synthesis stock assessment model from 
#'   which to create the OM. Currently, only allows models in the package, so 
#'   valid inputs are: \code{"cod"}.
#' @param use_SS_boot Should a bootstrapped data set generated by SS be used? 
#'   Defaults to TRUE.
#' @template MS
#' @param EM_name Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name 
#'   is NULL and  \code{MS = "EM}, then SSMSE will look for the estimation model
#'   in the path specified in EM_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_dir Relative or absolute path to the estimation model, if using a 
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param out_dir The directory to which to write output. IF NULL, will default
#'   to the working directory.
#' @param nyrs Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param impl_error Future parameter to specify implementation error.
#' @param niter The iteration number
#' @template verbose
#' @importFrom SSutils copy_SS_inputs
#' @export
#' @examples 
#' \dontrun{
#'   # Create a temporary folder for the output and set the working directory:
#'   temp_path <- file.path(tempdir(), "run_SSMSE_iter-example")
#'   dir.create(temp_path, showWarnings = FALSE)
#'   wd <- getwd()
#'   setwd(temp_path)
#'   on.exit(setwd(wd), add = TRUE)
#'   on.exit(unlink(temp_path, recursive = TRUE), add = TRUE)
#'   # run 1 iteration and 1 scenario of SSMSE
#'   run_SSMSE_iter(OM_name = "cod", 
#'                  MS = "no_catch", 
#'                  out_dir = temp_path,
#'                  nyrs = 6, 
#'                  nyrs_assess = 3
#'                  )
#'   unlink(file.path(temp_path, "run_SSMSE_iter-example", "1"), 
#'          recursive = TRUE)
#'   # run 1 iteration and 1 scenario of SSMSE using an EM. Note that this
#'   # currently exits on error after the first loop.
#'      run_SSMSE_iter(OM_name = "cod",
#'                  MS = "EM",
#'                  out_dir = temp_path,
#'                  EM_name = "cod",
#'                  nyrs = 6,
#'                  nyrs_assess = 3
#'      )
#'  }

run_SSMSE_iter <- function(OM_name     = "cod", 
                           use_SS_boot = TRUE, 
                           EM_name     = NULL,
                           MS          = "last_yr_catch",
                           out_dir     = NULL,
                           nyrs        = 100, 
                           nyrs_assess = 3,
                           impl_error  = NULL,
                           niter = 1, 
                           verbose = FALSE) {
  # input checks ----
  pkg_mods <- list.files(system.file("extdata", "models", package = "SSMSE"))
  if(!OM_name %in% pkg_mods) {
    stop("Currently, OM_name can only be one of the following: ", pkg_mods)
  }
  # get and create directories ----
  # get the directory to the models
  pkg_dirs <- list.dirs(system.file("extdata", "models", package = "SSMSE"))
  SA_dir <- pkg_dirs[grep(OM_name, pkg_dirs, fixed = TRUE)]
  if(is.null(out_dir)) {
    out_dir <- file.path(getwd(), as.character(niter))
  } else {
    out_dir <- file.path(normalizePath(out_dir), as.character(niter))  
  } 
  dir.create(out_dir)
  # create the OM directory
  OM_dir <- file.path(out_dir, paste0(OM_name, "_OM"))
  dir.create(OM_dir)

  # MSE first iteration ----
  # turn the EM into an OM
  create_OM(OM_dir = OM_dir, SA_dir, overwrite = TRUE, verbose = verbose)
  # Complete the OM run so it can be use for expect values or bootstrap
  if(use_SS_boot == TRUE) {
    OM_data <- run_OM(OM_dir = OM_dir, boot = use_SS_boot, nboot = 1, 
                           verbose = verbose, init_run = TRUE)
  }
  if(use_SS_boot == FALSE) {
    stop("Currently, only sampling can be done using the bootstrapping ", 
         "capabilities within SS")
    # TODO: add sampling functionsthen run a future sampling function that would
    # make it into a dataset.
  }
  # get catch using the chosen management strategy ----
  # This can use an estimation model or EM proxy, or just be a simple management
  # strategy
  new_catch_df <- parse_MS(MS = MS, EM_name = EM_name, EM_dir = EM_dir)
  # Next iterations of MSE procedure ----
  # set up all the years when the assessment will be done.
  # remove first value, because done in the intialization stage.
  styr_MSE <- OM_data$endyr
  assess_yrs <- seq(styr_MSE, styr_MSE + nyrs, nyrs_assess)
  assess_yrs <- assess_yrs[-1]
  # Loop over the assessment years.
  for (yr in assess_yrs) {
    check_future_catch(catch = new_catch_df, 
                       OM_dir = OM_dir,
                       catch_units = "bio")
    #add catch to the OM
    extend_OM(catch = new_catch_df, 
              OM_dir = OM_dir, 
              nyrs_extend = nyrs_assess,
              verbose = verbose)
    # rerun OM, get samples, etc. ()
    new_OM_data <- run_OM(OM_dir = OM_dir, boot = use_SS_boot, nboot = 1, 
                           verbose = verbose)
    # Only want data for the new years: (yr-nyrs_assess):yr
    # create the new dataset to input into the EM
    # loop EM and get management quantities.
    # TODO: make parsing the management stategy to get the new catch dataframe
    # a separate function
    if(!is.null(EM_name)){
      stop("Using an EM in future loops has not yet been implemented")
    } else {
      if(MS == "last_yr_catch") {
        #TODO: extend this approach in the case of multiple fishery fleets.
        # get last year catch. Make sure this will work?
        new_catch <- rep(OM_data$catch$catch[nrow(OM_data$catch)], 
                         length.out = nyrs_assess)
        new_catch_df <- data.frame(year = (yr + 1):(yr + nyrs_assess), 
                                   # assume always useing the same fleet and season for now
                                   seas = OM_data$catch$seas[nrow(OM_data$catch)],
                                   fleet = OM_data$catch$fleet[nrow(OM_data$catch)],
                                   catch = new_catch,
                                   catch_se = OM_data$catch$fleet[nrow(OM_data$catch)]$catch_se)
      } else if(MS == "no_catch") {
        new_catch_df <- data.frame(year = (yr + 1):(yr + nyrs_assess), 
                                   # assume always useing the same fleet and season for now
                                   seas = OM_data$catch$seas[nrow(OM_data$catch)],
                                   fleet = OM_data$catch$fleet[nrow(OM_data$catch)],
                                   catch = 0,
                                   catch_se = OM_data$catch$catch_se[nrow(OM_data$catch)])
      } else {
        stop("The only MS (management strategy) currently implemented is ",
             "last_yr_catch")
      }
    }
  }
  invisible(TRUE)
}