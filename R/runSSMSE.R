#' run an MSE using SS OMs
#' 
#' High level function to run a management strategy evaluation using Stock
#' Synthesis as the Operating model(s)
#' @param scen_list A list containing the design for all scenarios and
#'  iterations of the model. Each list component is named according to its 
#'  scenario and contains a list of the other parameters below, asides from 
#'  scen_name vec.
#'  Contains columns for each of the parameters listed
#'  below, except verbose. If a column is missing, its value is assumed to be 
#'  null or NA, as appropriate. Note that all other inputs (except for verbose)
#'  are ignored if scen_list is specified.
#' @param scen_name_vec A vector containing names of the scenarios. The 
#' directory containing all scenario model runs for 
#' @param iter_list A vector of integers to refer each iteration of the scenario.
#'  The length of this vector will be the number of iterations run for the 
#'  scenario.
#' @param OM_name_vec Name of a valid Stock Synthesis stock assessment model from 
#'   which to create the OM. Currently, only allows models in the package, so 
#'   valid inputs are: \code{"cod"}.
#' @param use_SS_boot_vec Should a bootstrapped data set generated by SS be used? 
#'   Defaults to TRUE.
#' @param MS_vec Vector of management strategies.
#' @param EM_name_vec Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name 
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_dir_vec Relative or absolute path to the estimation model, if using a 
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param out_dir_scen_vec The directory to which to write output. IF NULL, will default
#'   to the working directory.
#' @param nyrs_vec Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess_vec The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param impl_error_vec Future parameter to specify implementation error.
#' @param dat_str_list A optional list of lists including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found 
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out.
#' @template verbose
#' @export
#' @examples
#'   \dontrun{
#'   my_dir <- file.path(tempdir(), "ex-run_SSMSE")
#'   dir.create(my_dir)
#'   # For the EM, use the specified data structure
#'   my_dat_str_list <- list(NULL,
#'                          list(
#'                            catch = data.frame(year = 101:106,
#'                                               seas = 1,
#'                                               fleet = 1),
#'                            CPUE = data.frame(year = c(102, 105),
#'                                              seas = 7,
#'                                              index = 2)
#'                             )
#'                         )
#'   # Use the default parameter values, except for the once specified.
#'   # Note that the scen_list, either specified or internally created in the 
#'   # function is returned.
#'   input_list <- run_SSMSE(out_dir_scen_vec = my_dir,
#'                           dat_str_list = my_dat_str_list)
#'   unlink(my_dir, recursive = TRUE)
#'  }
run_SSMSE <- function(scen_list = NULL,
                      scen_name_vec = c("scen_1", "scen_2"),
                      iter_list = list(1:2, 3:4),
                      OM_name_vec     = "cod", 
                      use_SS_boot_vec = TRUE, 
                      EM_name_vec     = c(NA, "cod"),
                      EM_dir_vec      = NULL,
                      MS_vec          = c("no_catch", "EM"),
                      out_dir_scen_vec = NULL,
                      nyrs_vec        = 6, 
                      nyrs_assess_vec = 3,
                      impl_error_vec  = NULL,
                      dat_str_list = NULL,
                      verbose = FALSE) {
  # construct scen_list from other parameters.
  if(is.null(scen_list)) {
   scen_list <- create_scen_list(scen_name_vec,
                                iter_list, 
                                OM_name_vec,
                                use_SS_boot_vec,
                                EM_name_vec,
                                EM_dir_vec,
                                MS_vec,
                                out_dir_scen_vec,
                                nyrs_vec,
                                nyrs_assess_vec,
                                impl_error_vec,
                                dat_str_list) 
  }
  # check list and change if need to duplicate values. 
  scen_list <- check_scen_list(scen_list, verbose = verbose)
  # pass each scenario to run
  for (i in seq_along(scen_list)) {
    tmp_scen <- scen_list[[i]]
    #run for each scenario
    run_SSMSE_scen(scen_name    = names(scen_list)[i],
                   iter         = tmp_scen[["iter"]],
                   OM_name      = tmp_scen[["OM_name"]], 
                   use_SS_boot  = tmp_scen[["use_SS_boot"]], 
                   EM_name      = tmp_scen[["EM_name"]],
                   EM_dir       = tmp_scen[["EM_dir"]],
                   MS           = tmp_scen[["MS"]],
                   out_dir_scen = tmp_scen[["out_dir_scen"]],
                   nyrs         = tmp_scen[["nyrs"]], 
                   nyrs_assess  = tmp_scen[["nyrs_assess"]],
                   impl_error   = tmp_scen[["imp_error"]],
                   dat_str      = tmp_scen[["dat_str"]],
                   verbose = verbose)
  }
  message("Completed all SSMSE scenarios")
  invisible(scen_list)
}

#' Run an MSE scenario using SS OM
#' 
#' High level function to run 1 scenario (but potentially many iterations) for 
#' a management strategy evaluation using Stock Synthesis as the Operating Model
#' @param scen_name Name of the scenario. The directory containing all scenario
#'  model runs for 
#' @param iter A vector of integers to refer each iteration of the scenario.
#'  The length of this vector will be the number of iterations run for the 
#'  scenario.
#' @param OM_name Name of a valid Stock Synthesis stock assessment model from 
#'   which to create the OM. Currently, only allows models in the package, so 
#'   valid inputs are: \code{"cod"}.
#' @param use_SS_boot Should a bootstrapped data set generated by SS be used? 
#'   Defaults to TRUE.
#' @template MS
#' @param EM_name Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name 
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_dir Relative or absolute path to the estimation model, if using a 
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param out_dir_scen The directory to which to write output. IF NULL, will default
#'   to the working directory.
#' @param nyrs Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param impl_error Future parameter to specify implementation error.
#' @param dat_str A optional list including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found 
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out.
#' @template verbose
#' @export
#' @examples
#' \dontrun{
#'   # Create a temporary folder for the output and set the working directory:
#'   temp_path <- file.path(tempdir(), "run_SSMSE_scen-example")
#'   dir.create(temp_path, showWarnings = FALSE)
#'   
#'   # run 2 iteration and 1 scenario of SSMSE
#'   run_SSMSE_scen(scen_name = "no_catch",
#'                  iter = 1:2,
#'                  OM_name = "cod",
#'                  MS = "no_catch",
#'                  out_dir_scen = temp_path,
#'                  nyrs = 6,
#'                  nyrs_assess = 3
#'                  )
#'   unlink(temp_path, recursive = TRUE)
#'}
                
run_SSMSE_scen <- function(scen_name = "scen_1",
                            iter = 1:2,
                            OM_name     = "cod", 
                            use_SS_boot = TRUE, 
                            EM_name     = NULL,
                            EM_dir      = NULL,
                            MS          = "no_catch",
                            out_dir_scen = NULL,
                            nyrs        = 100, 
                            nyrs_assess = 3,
                            impl_error  = NULL,
                            dat_str = NULL,
                            verbose = FALSE) {
  # create the out_dir to store all files for all iter in the scenario.
  if(is.null(out_dir_scen)) {
    out_dir_iter <- scen_name
  } else {
    out_dir_iter <- file.path(out_dir_scen, scen_name)
  }
  dir.create(out_dir_iter)
  for(i in iter) { #TODO: make work in parallel.
    run_SSMSE_iter(niter = i,
                   OM_name     = OM_name,
                   use_SS_boot = use_SS_boot,
                   EM_name     = EM_name,
                   EM_dir      = EM_dir,
                   MS          = MS,
                   out_dir     = out_dir_iter,
                   nyrs        = nyrs, 
                   nyrs_assess = nyrs_assess,
                   impl_error  = impl_error,
                   dat_str     = dat_str,
                   verbose     = verbose)
  }
  message("Completed all iterations for scenario ", scen_name)
  invisible(scen_name)
}

#' Run one iteration of an MSE using SS OM
#' 
#' High level function to run 1 iteration of a scenario for a management 
#' strategy evaluation using Stock Synthesis as the Operating model.
#' 
#' @param OM_name Name of a valid Stock Synthesis stock assessment model from 
#'   which to create the OM. Currently, only allows models in the package, so 
#'   valid inputs are: \code{"cod"}.
#' @param use_SS_boot Should a bootstrapped data set generated by SS be used? 
#'   Defaults to TRUE.
#' @template MS
#' @param EM_name Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name 
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_dir Relative or absolute path to the estimation model, if using a 
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param out_dir The directory to which to write output. IF NULL, will default
#'   to the working directory.
#' @param nyrs Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param impl_error Future parameter to specify implementation error.
#' @param niter The iteration number
#' @param dat_str A optional list including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found 
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out.
#' @template verbose
#' @importFrom SSutils copy_SS_inputs
#' @export
#' @author Kathryn Doering
#' @examples 
#' \dontrun{
#'   # Create a temporary folder for the output
#'   temp_path <- file.path(tempdir(), "run_SSMSE_iter-ex")
#'   dir.create(temp_path)
#'   
#'   # run 1 iteration and 1 scenario of SSMSE
#'   run_SSMSE_iter(OM_name = "cod",
#'                  MS = "no_catch",
#'                  out_dir = temp_path,
#'                  nyrs = 6,
#'                  nyrs_assess = 3
#'                  )
#'   unlink(file.path(temp_path, "1"), recursive = TRUE)
#'   # run 1 iteration and 1 scenario of SSMSE using an EM.
#'      run_SSMSE_iter(OM_name = "cod",
#'                  MS = "EM",
#'                  out_dir = temp_path,
#'                  EM_name = "cod",
#'                  nyrs = 6,
#'                  nyrs_assess = 3,
#'                  dat_str = list(
#'                    catch = data.frame(year = 101:106, seas = 1, fleet = 1),
#'                    CPUE = data.frame(year = c(102, 105), seas = 7, index = 2)
#'                  )
#'      )
#'      unlink(temp_path, recursive = TRUE)
#'  }

run_SSMSE_iter <- function(OM_name     = "cod", 
                           use_SS_boot = TRUE, 
                           EM_name     = NULL,
                           EM_dir      = NULL,
                           MS          = "last_yr_catch",
                           out_dir     = NULL,
                           nyrs        = 100, 
                           nyrs_assess = 3,
                           impl_error  = NULL,
                           niter = 1, 
                           dat_str = NULL,
                           verbose = FALSE) {
  # input checks ----
  pkg_mods <- list.files(system.file("extdata", "models", package = "SSMSE"))
  if(!OM_name %in% pkg_mods) {
    stop("Currently, OM_name can only be one of the following: ", pkg_mods)
  }
  # get and create directories ----
  # get the directory to the models
  pkg_dirs <- list.dirs(system.file("extdata", "models", package = "SSMSE"))
  SA_dir <- pkg_dirs[grep(OM_name, pkg_dirs, fixed = TRUE)]
  if(is.null(out_dir)) out_dir <- getwd()
  out_dir <- file.path(out_dir, as.character(niter))
  dir.create(out_dir)
  # create the OM directory
  OM_dir <- file.path(out_dir, paste0(OM_name, "_OM"))
  dir.create(OM_dir)

  # MSE first iteration ----
  # turn the stock assessment model into an OM
  create_OM(OM_dir = OM_dir, SA_dir = SA_dir, overwrite = TRUE, add_dummy_dat = FALSE,
            verbose = verbose, writedat = TRUE)
  message("Finished initialization of OM for iteration ", niter, ".")
  # Complete the OM run so it can be use for expect values or bootstrap
  if(use_SS_boot == TRUE) {
    OM_dat <- run_OM(OM_dir = OM_dir, boot = use_SS_boot, nboot = 1, 
                           verbose = verbose, init_run = TRUE)
  }
  if(use_SS_boot == FALSE) {
    stop("Currently, only sampling can be done using the bootstrapping ", 
         "capabilities within SS")
    # TODO: add sampling functions then run a future sampling function that would
    # make it into a dataset.
  }
  # get catch using the chosen management strategy ----
  # This can use an estimation model or EM proxy, or just be a simple management
  # strategy
  new_catch_df <- parse_MS(MS = MS, EM_name = EM_name, EM_dir = EM_dir, 
                           out_dir = out_dir, OM_dat = OM_dat, 
                           verbose = verbose, nyrs_assess = nyrs_assess)
  message("Finished getting new catch (years ", OM_dat$endyr, " to ", 
          (OM_dat$endyr + nyrs_assess),") to feed into OM for iteration ", 
          niter, ".")
  # Next iterations of MSE procedure ----
  # set up all the years when the assessment will be done.
  # remove first value, because done in the intialization stage.
  styr_MSE <- OM_dat$endyr
  assess_yrs <- seq(styr_MSE, styr_MSE + nyrs, nyrs_assess)
  assess_yrs <- assess_yrs[-1]
  # Loop over the assessment years.
  for (yr in assess_yrs) {
    # checks, esp. to make sure future catch is not larger than the population
    # biomass (or size, depending on units)
    check_future_catch(catch = new_catch_df, 
                       OM_dir = OM_dir,
                       catch_units = "bio")
    #add new years of catch to the OM and add dummy values where necessary.
    extend_OM(catch = new_catch_df, 
              OM_dir = OM_dir, 
              dummy_dat_scheme = "all", 
              nyrs_extend = nyrs_assess,
              verbose = verbose)
    # rerun OM (without estimation), get samples (or expected values)
    if(use_SS_boot == TRUE) {
    new_OM_dat <- run_OM(OM_dir = OM_dir, boot = use_SS_boot, nboot = 1, 
                           verbose = verbose)
    } else {
      stop("Currently, only sampling can be done using the bootstrapping ", 
           "capabilities within SS")
    }
    # Only want data for the new years: (yr+nyrs_assess):yr
    # create the new dataset to input into the EM
    # loop EM and get management quantities.
    # TODO: make parsing the management stategy to get the new catch dataframe
    # a separate function - need separate function from already created? Or 
    # build on the exiting one?
    #parse_MS_future(dat_str = dat_str)
    new_catch_df <- parse_MS(MS = MS, EM_name = EM_name, EM_dir = EM_dir, 
                             out_dir = out_dir, OM_dat = new_OM_dat, 
                             init_loop = FALSE, verbose = verbose,
                             nyrs_assess = nyrs_assess, 
                             dat_yrs = (yr + 1):(yr + nyrs_assess),
                             dat_str = dat_str)
  message("Finished getting new catch (years ", (yr + 1), " to ", 
          (yr + nyrs_assess), ") to feed into OM for iteration ", niter, ".")
  }
  message("Finished iteration ", niter, ".")
  invisible(TRUE)
}