#' run an MSE using SS OMs
#'
#' High level function to run a management strategy evaluation using Stock
#' Synthesis as the Operating model(s)
#' @param scen_list A list containing the design for all scenarios and
#'  iterations of the model. Each list component is named according to its
#'  scenario and contains a list of the other parameters below, asides from
#'  scen_name vec.
#'  Contains columns for each of the parameters listed
#'  below, except verbose. If a column is missing, its value is assumed to be
#'  null or NA, as appropriate. Note that all other inputs (except for verbose)
#'  are ignored if scen_list is specified.
#' @param scen_name_vec A vector containing names of the scenarios. The each
#'  string will be a directory containing all the model runs for a scenario.s
#' @param out_dir_scen_vec The directory to which to write output. IF NULL, will
#'  default to the working directory.
#' @param iter_list A vector of integers to refer each iteration of the scenario.
#'  The length of this vector will be the number of iterations run for the
#'  scenario.
#' @param OM_name_vec Name of a valid Stock Synthesis stock assessment model from
#'   which to create the OM. Currently, only allows models in the package, so
#'   valid inputs are: \code{"cod"}.
#' @param OM_in_dir_vec Vector of relative or absolute paths to the operating
#'  model, if using a model outside of the SSMSE package.
#' @param EM_name_vec Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_in_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_in_dir_vec Relative or absolute path to the estimation model, if using
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param MS_vec Vector of management strategies.
#' @param use_SS_boot_vec Should a bootstrapped data set generated by SS be used?
#'   Defaults to TRUE.
#' @param nyrs_vec Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess_vec The number of years between assessments. E.g., if an
#'  assessment is conducted every 3 years, put 3 here. A single integer value.
#'  (NOTE: This could be made more flexible by instead reading in a vector of
#'  assessment years, so users could specify irregular numbers of yrs between
#'  assessments.)
#' @param scope Assign the scope of random deviations for rec devs and implementation error.
#' single integer value input where 1=values are identical across all scenarios and iterations
#' (if rec_dev_pattern=user input a vector of length nyrs_vec), 2 (default)=values are random
#' across iterations but the same iterations are used across scenarios
#' (if rec_dev_pattern=user input a matrix with ncols=nyrs_vec and nrows=number of iterations),
#' 3=values are random across all iterations and scenarios (if rec_dev_pattern=user input
#' a matrix with ncols=nyrs_vec and nrows=(number of iterations)*(number of scenarios)).
#' @param rec_dev_pattern Parameter to specify future rec devs. Input options include:
#' 1) "none" to set all future devs to zero (default). 2) "rand" automatically assign normally
#' distributed random recruitment deviations. Input a vector of two values to rec_dev_pars
#' to specify the max number of years over which the sum of rec_devs can diverge from
#' zero and a scalar multiplyer of standard deviation relative to the historic OM. if
#' rec_dev_pars=NULL defaults to c(nyrs_assess, 1). 3) "user" applys a user input vector or
#' matrix of recruitement deviations of length equal nyrs input the vector/matrix to rec_dev-pars.
#' @param rec_dev_pars Input the required parameters as specified by rec_dev_pattern choice.
#' @param impl_error_pattern Parameter to specify future implementation error. Input options include:
#' 1) "none" to set all future catches equal to expected (default). 2) "rand" automatically assign
#' achieved catch relative to expected catch as log normally distributed. Input
#' a vector of ((nseas x nfleet x 2)+ 1) values to impl_error_pars to specify the max number
#' of years over which the achieved mean catch can diverge from the mean specified, the mean
#' (default 1 such that achieved=expected), and the standard devation. If impl_error__pars=NULL defaults to
#' c(nyrs_assess, rep(1,(nfleetxnseas)), rep(0,(nfleetxnseas))). 3) "user" applys a user input vector
#' or matrix of implementation errors of length/columns equal to nyrs x nseas x Nfleets
#' and rows based on assigned scope. Input the vector/matrix to impl_error_pars.
#' @param impl_error_pars Input the required parameters as specified by impl_error_pattern choice.
#' @param sample_struct_list A optional list of lists including which years, seasons,
#'  and fleets should be  added from the OM into the EM for different types of
#'  data. If NULL, the data structure will try to be infered from the pattern
#'  found for each of the datatypes within the EM datafiles. Include this
#'  strucutre for the number of years to extend the model out.
#' @template verbose
#' @export
#' @author Kathryn Doering & Nathan Vaughan
#' @examples
#'
#' \dontrun{
#' my_dir <- file.path(tempdir(), "ex-run_SSMSE")
#'   dir.create(my_dir)
#'   # For the EM, use the specified data structure
#'   my_sample_struct_list <- list(NULL,
#'                          list(
#'                            catch = data.frame(Yr = 101:106,
#'                                               Seas = 1,
#'                                               FltSvy = 1,
#'                                               SE = 0.05),
#'                            CPUE = data.frame(Yr = c(102, 105),
#'                                              Seas = 7,
#'                                              FltSvy = 2, 
#'                                              SE = 0.01), 
#'                           lencomp = data.frame(Yr = c(102, 105), Seas = 1, 
#'                                                FltSvy = 1, Sex = 0,
#'                                                Part = 0, Nsamp = 100),
#'                             )
#'                         )
#'   # Use the default parameter values, except for the once specified.
#'   # Note that the scen_list, either specified or internally created in the
#'   # function is returned.
#'   input_list <- run_SSMSE(out_dir_scen_vec = my_dir,
#'                           sample_struct_list = my_sample_struct_list)
#'   unlink(my_dir, recursive = TRUE)
#' }
run_SSMSE <- function(scen_list = NULL,
                      scen_name_vec = c("scen_1", "scen_2"),
                      out_dir_scen_vec = NULL,
                      iter_list = list(1:2, 1:2),
                      OM_name_vec = "cod",
                      OM_in_dir_vec = NULL,
                      EM_name_vec = c(NA, "cod"),
                      EM_in_dir_vec = NULL,
                      MS_vec = c("no_catch", "EM"),
                      use_SS_boot_vec = TRUE,
                      nyrs_vec = 6,
                      nyrs_assess_vec = 3,
                      scope = 2,
                      rec_dev_pattern = "none",
                      rec_dev_pars = NULL,
                      impl_error_pattern = "none",
                      impl_error_pars = NULL,
                      sample_struct_list = NULL,
                      verbose = FALSE) {
  # Note that all input checks are done in the check_scen_list function.
  # construct scen_list from other parameters.
  # Get directory of base OM files
  OM_dir <- locate_in_dirs(OM_name_vec, OM_in_dir_vec)
  # Read in starter file
  start <- r4ss::SS_readstarter(file.path(OM_dir, "starter.ss"),
                                verbose = FALSE)
  # Read in data file
  dat <- r4ss::SS_readdat(file.path(OM_dir, start$datfile),
                          section = 1,
                          verbose = FALSE)
  # Read in control file
  ctl <- r4ss::SS_readctl(file = file.path(OM_dir, start$ctlfile),
                          use_datlist = TRUE, datlist = dat,
                          verbose = FALSE)
  # Read in parameter file
  parlist <- r4ss::SS_readpar_3.30(parfile = file.path(OM_dir, "ss.par"),
                                   datsource = dat, ctlsource = ctl,
                                   verbose = FALSE)
  rec_dev_comb <- rbind(parlist$recdev1, parlist$recdev2)
  rec_stddev <- stats::sd(rec_dev_comb[, 2])

  rec_dev_list <- build_rec_devs(nyrs_vec, nyrs_assess_vec, scope, rec_dev_pattern, rec_dev_pars, rec_stddev, length(scen_name_vec), iter_list)

  n_impl_error_groups <- dat$nseas * dat$Nfleet

  impl_error <- build_impl_error(nyrs_vec, nyrs_assess_vec, n_impl_error_groups, scope, impl_error_pattern, impl_error_pars, length(scen_name_vec), iter_list)

  if (is.null(scen_list)) {
   scen_list <- create_scen_list(scen_name_vec = scen_name_vec,
                                 out_dir_scen_vec = out_dir_scen_vec,
                                 iter_list = iter_list,
                                 OM_name_vec = OM_name_vec,
                                 OM_in_dir_vec = OM_in_dir_vec,
                                 EM_name_vec = EM_name_vec,
                                 EM_in_dir_vec = EM_in_dir_vec,
                                 MS_vec = MS_vec,
                                 use_SS_boot_vec = use_SS_boot_vec,
                                 nyrs_vec = nyrs_vec,
                                 nyrs_assess_vec = nyrs_assess_vec,
                                 sample_struct_list = sample_struct_list)
  }
  # check list and change if need to duplicate values.
  scen_list <- check_scen_list(scen_list, verbose = verbose)
  # pass each scenario to run
  for (i in seq_along(scen_list)) {
    tmp_scen <- scen_list[[i]]
    # run for each scenario
    run_SSMSE_scen(scen_name = names(scen_list)[i],
                   out_dir_scen = tmp_scen[["out_dir_scen"]],
                   iter = tmp_scen[["iter"]],
                   OM_name = tmp_scen[["OM_name"]],
                   OM_in_dir = tmp_scen[["OM_in_dir"]],
                   EM_name = tmp_scen[["EM_name"]],
                   EM_in_dir = tmp_scen[["EM_in_dir"]],
                   MS = tmp_scen[["MS"]],
                   use_SS_boot = tmp_scen[["use_SS_boot"]],
                   nyrs = tmp_scen[["nyrs"]],
                   nyrs_assess = tmp_scen[["nyrs_assess"]],
                   rec_devs_scen = rec_dev_list[[i]],
                   impl_error = impl_error[[i]],
                   sample_struct = tmp_scen[["sample_struct"]],
                   verbose = verbose)
  }
  message("Completed all SSMSE scenarios")
  invisible(scen_list)
}

#' Run an MSE scenario using SS OM
#'
#' High level function to run 1 scenario (but potentially many iterations) for
#' a management strategy evaluation using Stock Synthesis as the Operating Model
#' @param scen_name Name of the scenario. The directory containing all the model
#'  runs the scenario will be stored within a folder of this name.
#' @param out_dir_scen The directory to which to write output. IF NULL, will
#'  default to the working directory.
#' @param iter A vector of integers to refer each iteration of the scenario.
#'  The length of this vector will be the number of iterations run for the
#'  scenario.
#' @param OM_name Name of a valid Stock Synthesis stock assessment model from
#'   which to create the OM. Currently, only allows models in the package, so
#'   valid inputs are: \code{"cod"}.
#' @param OM_in_dir Relative or absolute path to the operating model, if using a
#'   model outside of the SSMSE package.
#' @param EM_name Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'  Synthesis stock assessment model to use as an EM. If the value of EM_name
#'  is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'  in the path specified in EM_in_dir. valid inputs for EM_name are: \code{"cod"}
#'  or \code{NULL}.
#' @param EM_in_dir Relative or absolute path to the estimation model, if using a
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @template MS
#' @param use_SS_boot Should a bootstrapped data set generated by SS be used?
#'   Defaults to TRUE.
#' @param nyrs Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param rec_devs_scen List containing a recruitment deviation vector for each
#'   iteration.
#' @param impl_error List containing an implementation error vector for each
#'   iteration.
#' @param sample_struct A optional list including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out.
#' @template verbose
#' @export
#' @author Kathryn Doering & Nathan Vaughan
#' @examples
#' \dontrun{
#' # Create a temporary folder for the output and set the working directory:
#'   temp_path <- file.path(tempdir(), "run_SSMSE_scen-example")
#'   dir.create(temp_path, showWarnings = FALSE)
#'
#'   # run 2 iteration and 1 scenario of SSMSE
#'   run_SSMSE_scen(scen_name = "no_catch",
#'                  iter = 1:2,
#'                  OM_name = "cod",
#'                  MS = "no_catch",
#'                  out_dir_scen = temp_path,
#'                  nyrs = 6,
#'                  nyrs_assess = 3
#'                  )
#'   unlink(temp_path, recursive = TRUE)
#' }
#'
run_SSMSE_scen <- function(scen_name = "scen_1",
                           out_dir_scen = NULL,
                           iter = 1:2,
                           OM_name = "cod",
                           OM_in_dir = NULL,
                           EM_name = NULL,
                           EM_in_dir = NULL,
                           MS = "no_catch",
                           use_SS_boot = TRUE,
                           nyrs = 100,
                           nyrs_assess = 3,
                           rec_devs_scen = NULL,
                           impl_error = NULL,
                           sample_struct = NULL,
                           verbose = FALSE) {
  # input checks
  assertive.types::assert_is_a_string(scen_name)
  assertive.properties::assert_is_atomic(iter)
  assertive.types::assert_is_any_of(iter, classes = c("numeric", "integer"))
  if (!is.null(OM_name)) assertive.types::assert_is_a_string(OM_name)
  assertive.types::assert_is_a_bool(use_SS_boot)
  if (!is.null(EM_name)) assertive.types::assert_is_a_string(EM_name)
  if (!is.null(EM_in_dir)) assertive.types::assert_is_a_string(EM_in_dir)
  assertive.types::assert_is_a_string(MS)
  if (!is.null(out_dir_scen)) assertive.types::assert_is_a_string(out_dir_scen)
  assertive.types::assert_is_any_of(nyrs, classes = c("numeric", "integer"))
  assertive.properties::assert_is_of_length(nyrs, 1)
  assertive.types::assert_is_any_of(nyrs_assess, classes = c("numeric", "integer"))
  assertive.properties::assert_is_of_length(nyrs_assess, 1)
  if (!is.null(sample_struct)) assertive.types::assert_is_list(sample_struct)
  assertive.types::assert_is_a_bool(verbose)

  # create the out_dir to store all files for all iter in the scenario.
  if (is.null(out_dir_scen)) {
    out_dir_iter <- scen_name
  } else {
    out_dir_iter <- file.path(out_dir_scen, scen_name)
  }
  dir.create(out_dir_iter)
  for (i in iter) { # TODO: make work in parallel.
    run_SSMSE_iter(out_dir = out_dir_iter,
                   OM_name = OM_name,
                   OM_in_dir = OM_in_dir,
                   EM_name = EM_name,
                   EM_in_dir = EM_in_dir,
                   MS = MS,
                   use_SS_boot = use_SS_boot,
                   nyrs = nyrs,
                   nyrs_assess = nyrs_assess,
                   rec_dev_iter = rec_devs_scen[[i]],
                   impl_error = impl_error[[i]],
                   niter = i,
                   sample_struct = sample_struct,
                   verbose = verbose)
  }
  message("Completed all iterations for scenario ", scen_name)
  invisible(scen_name)
}

#' Run one iteration of an MSE using SS OM
#'
#' High level function to run 1 iteration of a scenario for a management
#' strategy evaluation using Stock Synthesis as the Operating model.
#' @param out_dir The directory to which to write output. IF NULL, will default
#'   to the working directory.
#' @param OM_name Name of a valid Stock Synthesis stock assessment model from
#'   which to create the OM. Currently, valid inputs are: \code{"cod"} or NULL,
#'   if using a custom model with path specified in \code{OM_in_dir}.
#' @param OM_in_dir Relative or absolute path to the operating model, if using a
#'   model outside of the SSMSE package.
#' @template MS
#' @param EM_name Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_in_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_in_dir Relative or absolute path to the estimation model, if using a
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".

#' @param use_SS_boot Should a bootstrapped data set generated by SS be used?
#'   Defaults to TRUE.
#' @param nyrs Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param rec_dev_iter A recruitment deviation vector for the iteration.
#'  Dimensions are nyrs_assess\*number of fleets \* number of seasons
#' @param impl_error An implementation error vector for the iteration.
#'  Dimensions are nyrs_assess\*number of fleets \* number of seasons
#' @param niter The iteration number
#' @param sample_struct A optional list including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out. Note that the data should
#'  be specified using the list component names and column names as in would be
#'  used in \code{r4ss::SS_readdat()}. The run_SSMSE_iter function examples
#'  give an example of what this structure should be. Running the function 
#'  create_sample_struct() will also produce a sample_struct object in the 
#'  correct form. Can be NULL only when MS is not EM.
#' @template verbose
#' @export
#' @author Kathryn Doering & Nathan Vaughan
#' @examples
#' \dontrun{
#' # Create a temporary folder for the output
#'   temp_path <- file.path(tempdir(), "run_SSMSE_iter-ex")
#'   dir.create(temp_path)
#'
#'   # run 1 iteration and 1 scenario of SSMSE
#'   run_SSMSE_iter(OM_name = "cod",
#'                  MS = "no_catch",
#'                  out_dir = temp_path,
#'                  nyrs = 6,
#'                  nyrs_assess = 3
#'                  )
#'   unlink(file.path(temp_path, "1"), recursive = TRUE)
#'   # run 1 iteration and 1 scenario of SSMSE using an EM.
#'      run_SSMSE_iter(OM_name = "cod",
#'                  MS = "EM",
#'                  out_dir = temp_path,
#'                  EM_name = "cod",
#'                  nyrs = 6,
#'                  nyrs_assess = 3,
#'                  sample_struct = list(
#'                    catch = data.frame(Yr = 101:106, Seas = 1, FltSvy = 1, SE = 0.05),
#'                    CPUE = data.frame(Yr = c(102, 105), Seas = 7, FltSvy = 2, SE = 0.01),
#'                    lencomp = data.frame(Yr = c(102, 105), Seas = 1, FltSvy = 1,
#'                                         Sex = 0, Part = 0, Nsamp = 100),
#'                    agecomp = data.frame(Yr = c(102, 105), Seas = 1, FltSvy = 2,
#'                                         Sex = 0, Part = 0, Ageerr = 1,
#'                                         Lbin_lo = -1, Lbin_hi = -1, Nsamp = 50)
#'                  )
#'      )
#' unlink(temp_path, recursive = TRUE)
#' }
run_SSMSE_iter <- function(out_dir = NULL,
                           OM_name = "cod",
                           OM_in_dir = NULL,
                           EM_name = NULL,
                           EM_in_dir = NULL,
                           MS = "last_yr_catch",
                           use_SS_boot = TRUE,
                           nyrs = 100,
                           nyrs_assess = 3,
                           rec_dev_iter = NULL,
                           impl_error = NULL,
                           niter = 1,
                           sample_struct = NULL,
                           verbose = FALSE) {
  # input checks ----
  # checks for out_dir, OM_name, OM_in_dir, EM_name, EM_in_dir done in create_out_dirs
  assertive.types::assert_is_a_bool(use_SS_boot)
  assertive.types::assert_is_a_string(MS)
  assertive.types::assert_is_any_of(nyrs, c("integer", "numeric"))
  assertive.types::assert_is_any_of(nyrs_assess, c("integer", "numeric"))
  assertive.types::assert_is_any_of(niter, c("integer", "numeric"))
  if (!is.null(sample_struct)) {
    assertive.types::assert_is_list(sample_struct)
    check_sample_struct(sample_struct)
  } else {
    if(MS == "EM") {
      stop("sample_struct cannot be NULL when using an EM. Please specify. The ",
           "helper function create_sample_struct can be used to specify.")
    }
  }
  assertive.types::assert_is_a_bool(verbose)

  message("Starting iteration ", niter, ".")

  # get and create directories, copy model files ----
  # assign or reassign OM_dir and OM_in_dir in case they weren't specified
  # as inputs
  out_loc <- create_out_dirs(out_dir = out_dir, niter = niter, OM_name = OM_name,
                             OM_in_dir = OM_in_dir, MS = MS,
                                EM_name = EM_name, EM_in_dir = EM_in_dir)
  if (is.null(out_loc)) { # out loc returns false if the iteration was already run.
    return(FALSE)
  }
  OM_out_dir <- out_loc[["OM_out_dir"]]
  OM_in_dir <- out_loc[["OM_in_dir"]]
  EM_in_dir <- out_loc[["EM_in_dir"]]
  EM_out_dir <- out_loc[["EM_out_dir"]]
  if (!is.null(EM_out_dir)) {
    EM_out_dir_basename <- strsplit(EM_out_dir, "_init$")[[1]][1]
  }
  copy_model_files(OM_in_dir = OM_in_dir, OM_out_dir = OM_out_dir,
                   EM_in_dir = EM_in_dir, EM_out_dir = EM_out_dir)
  # clean model files ----
  # want to do this as soon as possible to "fail fast"
  # for now, this just gets rid of -year value observations, but could do
  # other things.
  clean_init_mod_files(OM_out_dir = OM_out_dir, EM_out_dir = EM_out_dir,
                       overwrite = TRUE)
  
  # convert sample_struct names ----
  # get the full sampling structure for components that the user didnt specify.
  # if meaning is ambiguous, then this will exit on error.
  if(!is.null(sample_struct)) {
    sample_struct <- get_full_sample_struct(sample_struct = sample_struct,
                           OM_out_dir = OM_out_dir)
    # convert to r4ss names
    sample_struct <- convert_to_r4ss_names(sample_struct)
  }
  # MSE first iteration ----
  # turn the stock assessment model into an OM
  # This function is now needed in order to make changes such as run from
  # the par file and potentially change F method to 2 to unify results.
  # TODO allow user to decide through this wrapper function to use add dummy data
  # or not.
  create_OM(OM_out_dir = OM_out_dir, overwrite = TRUE, add_dummy_dat = FALSE,
            verbose = verbose, writedat = TRUE, nyrs_assess = nyrs_assess,
            rec_devs = rec_dev_iter)

  # Complete the OM run so it can be use for expect values or bootstrap
  if (use_SS_boot == TRUE) {
    OM_dat <- run_OM(OM_dir = OM_out_dir, boot = use_SS_boot, nboot = 1,
                           verbose = verbose, init_run = TRUE)
  }
  if (use_SS_boot == FALSE) {
    stop("Currently, only sampling can be done using the bootstrapping ",
         "capabilities within SS")
    # TODO: add sampling functions then run a future sampling function that would
    # make it into a dataset.
  }
  message("Finished running and sampling OM for the historical period for ",
          "iteration ", niter, ".")
  # get catch/discard using the chosen management strategy ----
  # This can use an estimation model or EM proxy, or just be a simple management
  # strategy


  new_catch_list <- parse_MS(MS = MS, EM_out_dir = EM_out_dir, init_loop = TRUE,
                           OM_dat = OM_dat, OM_out_dir = OM_out_dir,
                           verbose = verbose, nyrs_assess = nyrs_assess)
  message("Finished getting catch (years ",
          (OM_dat$endyr + 1), " to ", (OM_dat$endyr + nyrs_assess),
          ") to feed into OM for iteration ", niter, ".")
  # Next iterations of MSE procedure ----
  # set up all the years when the assessment will be done.
  # remove first value, because done in the intialization stage.
  styr_MSE <- OM_dat$endyr
  assess_yrs <- seq(styr_MSE, styr_MSE + nyrs, nyrs_assess)
  assess_yrs <- assess_yrs[-1]
  # Loop over the assessment years.
  for (yr in assess_yrs) {
    # checks, esp. to make sure future catch is not larger than the population
    # biomass (or size, depending on units)
    # TODO: improve this function below; we need better checks for all the
    # new_catch_list components
    # check_future_catch(catch = new_catch_list[["catch_bio"]],
    #                    OM_dir = OM_out_dir,
    #                    catch_units = "bio")
    # add new years of catch to the OM and add dummy values where necessary.
    if (verbose) {
      message("Extending, running, and sampling from the OM though year ", yr,
              ".")
    }
    rec_devs_chunk <- rec_dev_iter[1:nyrs_assess]
    rec_dev_iter <- rec_dev_iter[-(1:nyrs_assess)]
    impl_error_chunk <- impl_error[1:(nyrs_assess * OM_dat$nseas * OM_dat$Nfleet)]
    impl_error <- impl_error[-(1:(nyrs_assess * OM_dat$nseas * OM_dat$Nfleet))]
    extend_OM(catch = new_catch_list[["catch"]],
              discards = new_catch_list[["discards"]],
              OM_dir = OM_out_dir,
              dummy_dat_scheme = "all",
              nyrs_extend = nyrs_assess,
              rec_devs = rec_devs_chunk,
              impl_error = impl_error_chunk,
              verbose = verbose)
    # rerun OM (without estimation), get samples (or expected values)
    if (use_SS_boot == TRUE) {
    new_OM_dat <- run_OM(OM_dir = OM_out_dir, boot = use_SS_boot, nboot = 1,
                           verbose = verbose)
    } else {
      stop("Currently, only sampling can be done using the bootstrapping ",
           "capabilities within SS")
    }
    message("Finished running and sampling OM through year ", new_OM_dat$endyr,
            ".")

    # if using an EM, want to save results to a new folder
    if (!is.null(EM_out_dir)) {
      new_EM_out_dir <- paste0(EM_out_dir_basename, "_", yr)
      dir.create(new_EM_out_dir)
      success <- copy_model_files(EM_in_dir = EM_out_dir,
                                  EM_out_dir = new_EM_out_dir)
      EM_out_dir <- new_EM_out_dir
    }
    # Only want data for the new years: (yr+nyrs_assess):yr
    # create the new dataset to input into the EM
    # loop EM and get management quantities.
    new_catch_list <- parse_MS(MS = MS,
                               EM_out_dir = EM_out_dir,
                               OM_dat = new_OM_dat,
                               init_loop = FALSE, verbose = verbose,
                               nyrs_assess = nyrs_assess,
                               OM_out_dir = OM_out_dir,
                               dat_yrs = (yr + 1):(yr + nyrs_assess),
                               sample_struct = sample_struct)
  message("Finished getting catch (years ", (yr + 1), " to ",
          (yr + nyrs_assess), ") to feed into OM for iteration ", niter, ".")
  }
  message("Finished iteration ", niter, ".")
  invisible(TRUE)
}
