# utility functions for the packages. Construct objects, move files, etc.

#' Create scen_list object to use in run_SSMSE function.
#' 
#' Function to create parameter \code{scen_list} in 
#' \code{\link{run_SSMSE}}, but also could be used by users to construct their
#' list prior to using \code{\link{run_SSMSE}}. Note that there is no error 
#' checking in this function, so getting output does not insure that this output
#' can be used as input to run_SSMSE.
#' 
#' @param scen_name_vec A vector containing names of the scenarios. Note that 
#'  this vector should be of type character, but if it is not, it will be 
#'  coerced to character.
#' @param iter_list A list of integers to refer each iteration of the scenario.
#'  The length of this vector will be the number of iterations run for the 
#'  scenario.
#' @param OM_name_vec Name of a valid Stock Synthesis stock assessment model from 
#'   which to create the OM. Currently, only allows models in the package, so 
#'   valid inputs are: \code{"cod"}.
#' @param use_SS_boot_vec Should a bootstrapped data set generated by SS be used? 
#'   Defaults to TRUE.
#' @param MS_vec Vector of management strategies.
#' @param EM_name_vec Should be NULL unless \code{MS = "EM"}. Name of a valid Stock
#'   Synthesis stock assessment model to use as an EM. If the value of EM_name 
#'   is NULL and  \code{MS = "EM"}, then SSMSE will look for the estimation model
#'   in the path specified in EM_dir. valid inputs for EM_name are: \code{"cod"}
#'    or \code{NULL}.
#' @param EM_dir_vec Relative or absolute path to the estimation model, if using a 
#'   model outside of the SSMSE package. Note that this value should be NULL if
#'   \code{MS} has a value other than "EM".
#' @param out_dir_scen_vec The directory to which to write output. IF NULL, will 
#'  default to the working directory and create subfolders for using the names
#'  in scen_name_vec. If has only one path, will use this location and create 
#'  subfolders for using the names in scen_name_vec. If has the same length as
#'  scen_name_vec, will match up with the names in scen_name_vec and ad a
#'  subfolder to each location using the names in scen_name_vec (this is mostly)
#'  to help verify which scenarios were run.
#' @param nyrs_vec Number of years beyond the years included in the OM to run the
#'   MSE. A single integer value.
#' @param nyrs_assess_vec The number of years between assessments. E.g., if an
#'   assessment is conducted every 3 years, put 3 here. A single integer value.
#'   (NOTE: we could make this more flexible by instead reading in a vector of
#'   assessment years, so users could specify irregular numbers of yrs between
#'   assessments.)
#' @param impl_error_vec Future parameter to specify implementation error.
#' @param dat_str_list A optional list of lists including which years, seasons, and fleets
#'  should be  added from the OM into the EM for different types of data.
#'  If NULL, the data structure will try to be infered from the pattern found 
#'  for each of the datatypes within the EM datafiles. Include this strucutre
#'  for the number of years to extend the model out.
#' @export
#' @author Kathryn Doering
#' @examples
#' scen_list <- create_scen_list(
#'                scen_name_vec = c("scen 1", "scen_2"),
#'                iter_list = list(1:2, 5:7),
#'                OM_name_vec = "cod",
#'                use_SS_boot_vec = TRUE,
#'                EM_name_vec = "cod",
#'                EM_dir_vec = NULL,
#'                MS_vec = "EM",
#'                out_dir_scen_vec = file.path("path", "to", "dir"),
#'                nyrs_vec = 6,
#'                nyrs_assess_vec = 3,
#'                impl_error_vec = NULL,
#'                dat_str_list = NULL
#'                 )
#'                 
create_scen_list <- function(scen_name_vec,
                             iter_list, 
                             OM_name_vec,
                             use_SS_boot_vec,
                             EM_name_vec,
                             EM_dir_vec,
                             MS_vec,
                             out_dir_scen_vec,
                             nyrs_vec,
                             nyrs_assess_vec,
                             impl_error_vec,
                             dat_str_list) {
  #note that input checking 
  scen_name_vec <- as.character(scen_name_vec)
  # construct list. Note that it may not be usable at this stage, but there
  # will be another function to check it.
  scen_list <-  lapply(scen_name_vec, function(x) NULL)
  names(scen_list) <- scen_name_vec
  
  # Note that the below is written as a function with documentation because it
  # was fairly long and the meaning of the variables may not be immediately
  # clear.
  
  # function to get the value for a scenario, which depends on if it is a list, 
  # vector, or null. also inculdes error checking.
  # 
  # @param num_scen Which number scenario in the list is this?
  # @param var The variable we want to pull output from. Should be a vector or
  # list, but has error checking in case it is not.
  # @param var_name The name of the variable, as a string.
  # @param len_scen_name_vec The total number of scenarios being investigated
  get_scen_list_val <- function(var, var_name, num_scen, len_scen_name_vec) {
    if(is.null(var)) {
      return_val <- NULL
    } else {
      if(length(grep("list", var_name)) == 1) {
        assertive.types::assert_is_list(var)
        if(length(var) == 1) {
          return_val <- var[[1]]
        } else if (length(var) == len_scen_name_vec) {
          return_val <- var[[num_scen]]
        } else {
          stop(var_name, " has length ", length(var), "but should either have ", 
               "length 1 or equal to the number of scenarios , (i.e., ",
               len_scen_name_vec, ".")
        }
      } else if (length(grep("vec", var_name)) == 1) {
      if(!is.vector(var)) {
        stop(var_name, " should be a vector, but is not. It currently looks ", 
             "like ", var, ". Please make it a vector.")
      }
      if(length(var) == 1) {
        return_val <- var[1]
      } else if(length(var) == len_scen_name_vec) {
        return_val <- var[num_scen]
      } else {
        stop(var_name, " has length ", length(var), "but should either have ", 
             "length 1 or equal to the number of scenarios , (i.e., ",
             len_scen_name_vec, ".")
      }
    }
    else {
    stop("var_name should have 'vec' as part of its name to indicate it is ",
         "a vector or 'list' to indicate it is a list, but did not have ", 
         "either terms. Please add this to the var name depending on its ",
         "structure.")
    }
      #use short circuiting && to avioid testing the second statement if legth
      # isn't 1. want to change NAs to NULLs to be consistent with what the 
      # function expects.
      if(length(return_val) == 1 && is.na(return_val)) {
        return_val <- NULL
      }
    }
    return_val
  }
  # use the function to get values and put them in for each list component.
  all_vars <- names(formals(SSMSE::create_scen_list))[-1]
  # get names without _list or _vec
  all_vars_new_names <- unlist(strsplit(all_vars, split = "_list$|_vec$"))
  scen_list <- vector(mode = "list", length = length(scen_name_vec))
  for (i in seq_along(scen_name_vec)) {
    tmp_vals <- lapply(all_vars, 
                      function(x, var_name, num_scen, len_scen_name_vec) {
                        get_scen_list_val(get(x),
                                          var_name = x,
                                          num_scen, 
                                          len_scen_name_vec)
                      },
                      num_scen = i, len_scen_name_vec = length(scen_name_vec))
    scen_list[[i]] <- tmp_vals
    #add names
    names(scen_list[[i]]) <- all_vars_new_names
  }
  names(scen_list) <- scen_name_vec
  # return list
  scen_list
}

#' return a value from a data frame
#'
#' Return a single value from a column of a dataframe using the method specified
#' @param data A dataframe which has a column that matches (at least partially)
#'  colname
#' @param method How should the value to be returned be selected? Current 
#'  options include "most_common_value", where the most common input uncertainty
#'  value will be returned and "only_value" where all input values must be the 
#'  same in data; if they are, this value will be returned. Otherwise, an error
#'  will be generated.
#' @param colname Column name as a string in \code{data}. Note that partial
#'  matching and regular expressions can be used.
#' @param group Column name as a string in \code{data} used to group the data 
#'  before calculating the input value to use. Defaults to NULL.
#' @return A value of the same type as \code{data[, colname]} if \code{group}
#'  is NULL, or a data.frame if \code{group} is specified.
#' @author Kathryn Doering
#' @details Note that this function was created intially to return a value to
#'  use as the input uncertainty, but it should be generalizable to pulling a 
#'  value from a column in any data frame using the method specified.
#' @examples
#'  dfr <- data.frame("year" = 1:5, 
#'                    "value" = c(2,2,2,3,3), 
#'                     "se_log" = 0.2)
#'  get_input_value(data = dfr, method = "most_common_value", colname = "se_log", 
#'                  group = "value")
#'  get_input_value(data = dfr, method = "most_common_value", colname = "value")
#'  get_input_value(data = dfr, method = "only_value", colname = "se_log")
#'  # generates an error:
#'  # get_input_value(data = dfr, method = "only_value", colname = "value")
get_input_value <- function(data, 
                               method = "most_common_value", 
                               colname, 
                               group = NULL) {
  #input checks
  assertive.types::assert_is_data.frame(data)
  assertive.properties::assert_has_colnames(data)
  assertive.types::assert_is_a_string(method)
  assertive.types::assert_is_a_string(colname)
  if(!is.null(group)) assertive.types::assert_is_a_string(group)
  method_values <- c("most_common_value", "only_value")
  if(!method %in% method_values) {
    stop("method possible values are: ", paste0(method_values, collapse = ", "), 
         "; method was specified as ", method)
  }
  selected_col <- grep(colname, colnames(data))
  selected_colname <- colnames(data)[selected_col]

  if(length(selected_col) == 0) {
    stop("column ", colname, " not found in data.")
  }
  if(length(selected_col) > 1) {
    stop("The value specified for colname ", colname, " selected more than 1",
         " column in data (columns matched: ", 
         paste0(selected_colname, collapse = ", "),
         "). Note that partial matching and regular expressions", 
         " are used to find the column(s) that match with colname.")
  }
  if(!is.null(group)) {
    group_orig <- group
    group_col <- grep(group, colnames(data))
    group <- colnames(data)[group_col]
    if(length(group) == 0) {
      stop("column ", group_orig, " not found in data.")
    }
    if(length(group) > 1) {
      stop("The value specified for colname ", group_orig, " selected more than 1",
           " column in data (columns matched: ", 
           paste0(group, collapse = ", "),
           "). Note that partial matching and regular expressions", 
           " are used to find the column(s) that match with colname.")
    }
    if(group == selected_colname) {
      stop("group and colname cannot be the same. Both selected column", 
           group)
    }
  }
  # get the value
  if(method == "most_common_value") {
    if(is.null(group)) {
      ux <- unique(data[, selected_col])
      val <- ux[which.max(tabulate(match(data[ ,selected_col], ux)))]
      assertive.properties::assert_is_of_length(val, 1)
    } else {
      val <- stats::aggregate(data[, selected_colname], 
                       by = list("group" = data[, group]), 
                       # find the most common value (mode)
                       FUN = function(x) {
                         unique(x)[which.max(tabulate(match(x, unique(x))))]
                       }, drop = FALSE
                       )
      assertive.types::assert_is_data.frame(val) #sanity check
      colnames(val) <- c(group, selected_colname)
    }
  }
  if(method == "only_value") {
    if(is.null(group)) {
      val <- unique(data[, selected_col])
      # check return value
      if(length(val) > 1) {
        stop("Multiple unique values were found in data with colname ", 
             selected_colname, 
             ". Because method is only_value, this function only works if all ", 
             "values in the column are the same.")
      }
      if(length(val) == 0) {
        stop("No value found in ", selected_colname, ".")
      }
      #sanity check for developers
      assertive.properties::assert_is_of_length(val, 1)
    } else {
      n_vals <- stats::aggregate(data[,selected_colname], 
                              by = list("group" = data[, group]), 
                              # find the most common value (mode)
                              FUN = function(x) {
                                length(unique(x))
                              }, drop = FALSE
      )
      if(any(unlist(n_vals[,"x"]) > 1)) {
        stop("Multiple unique values were found in data with colname ", 
             selected_colname, 
             "after grouping by ", group, ". Because method is only_value, ",
             "this function only works if all values in the column within the ",  
             "same grouping are the same.")
      }
      #TODO: need check if any are length 0??? or check outside function?
      # get the value
      val <- stats::aggregate(data[,selected_colname], 
       by = list("group" = data[, group]), 
       # find the most common value (mode)
       FUN = function(x) {
         return <- unique(x)
         if(length(return) > 1) {
           stop("Problem calculating.")
         }
         return
       }, drop = FALSE)
      assertive.types::assert_is_data.frame(val) #sanity check
      colnames(val) <- c(group, selected_colname)
    }
  }
  val
}
